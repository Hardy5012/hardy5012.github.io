<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Leaning Hardy</title>
    <link>https://hardy5012.github.io/post/</link>
    <description>Recent content in Posts on Leaning Hardy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 15 Nov 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://hardy5012.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>西瓜＋南瓜书学习笔记(1)</title>
      <link>https://hardy5012.github.io/2021/11/15/%E8%A5%BF%E7%93%9C%E5%8D%97%E7%93%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 15 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2021/11/15/%E8%A5%BF%E7%93%9C%E5%8D%97%E7%93%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>绪论 机器学习是从大量样本中学得模型，这是一个归纳的过程，学到的模型能很好的适用新的样本，则这个模型具有泛化能力。 训练学得的模型只是假设空间中</description>
    </item>
    
    <item>
      <title>tttt</title>
      <link>https://hardy5012.github.io/2021/11/15/%E8%A5%BF%E7%93%9C%E5%8D%97%E7%93%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 15 Nov 2021 00:00:00 +0800</pubDate>
      
      <guid>https://hardy5012.github.io/2021/11/15/%E8%A5%BF%E7%93%9C%E5%8D%97%E7%93%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>绪论 机器学习是从大量样本中学得模型，这是一个归纳的过程，学到的模型能很好的适用新的样本，则这个模型具有泛化能力。训练学得的模型只是假设空间中</description>
    </item>
    
    <item>
      <title>Hadoop HA env(1)</title>
      <link>https://hardy5012.github.io/2019/09/26/hadoop-env1/</link>
      <pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2019/09/26/hadoop-env1/</guid>
      <description>整体架构 概述 从 Hadoop2.0 开始，HDFS NameNode 和 YARN ResourceManger(JobTracker 在 2.0 中已经被整合到 YARN ResourceManger 之中) 的单点问题都得到了解决。HDFS NameNode 和 YARN ResourceManger 的基本原理是一样的， HA 功能通过配置</description>
    </item>
    
    <item>
      <title>spark env(1)</title>
      <link>https://hardy5012.github.io/2019/09/26/spark-env1/</link>
      <pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2019/09/26/spark-env1/</guid>
      <description>环境安装</description>
    </item>
    
    <item>
      <title>为运行的容器挂载文件目录</title>
      <link>https://hardy5012.github.io/2018/11/22/%E4%B8%BA%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Thu, 22 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/11/22/%E4%B8%BA%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/</guid>
      <description>在使用 docker 时，经常需要为已运行的容器挂载文件目录。方法如下: 首先使用 df 查看需要挂载的文件目录是在哪个文件系统上 1 2 3 4 5 #on the host: df /home/huaming_li/github Filesystem 1K-blocks Used Available Use% Mounted</description>
    </item>
    
    <item>
      <title>super 没那么简单</title>
      <link>https://hardy5012.github.io/2018/10/09/super%E6%B2%A1%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95/</link>
      <pubDate>Tue, 09 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/10/09/super%E6%B2%A1%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95/</guid>
      <description>大家都知道使用 super 来调用父类了方法，但如何正确使用 super 普遍知之甚少。 为了弄清它的原理，我们需要花点时间解释下 Python 是如何实现继承的。 对于你定义的每一</description>
    </item>
    
    <item>
      <title>Postgres 中的五种分页方式</title>
      <link>https://hardy5012.github.io/2018/03/28/postgres%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D%E5%88%86%E9%A1%B5%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Wed, 28 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/03/28/postgres%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D%E5%88%86%E9%A1%B5%E6%96%B9%E5%BC%8F/</guid>
      <description>任意查询分页 limit-offset limit-offset 是最简单，也是最危险的分页方式。不幸的是，它是 Web 应用程序开发教程的主要内容。对象关系映射（ORM）库使它变得简单而诱人，从 SQLAlchemy</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep24: When noexcept Really Matters</title>
      <link>https://hardy5012.github.io/2018/03/14/c-ep24-when-noexcept-really-matters/</link>
      <pubDate>Wed, 14 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/03/14/c-ep24-when-noexcept-really-matters/</guid>
      <description>对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道 函数不会抛出异常有助于简化调用该函数的代码；其次，如果编译器确认函</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep23: constexpr if</title>
      <link>https://hardy5012.github.io/2018/03/07/c-ep23-if-constexpt/</link>
      <pubDate>Wed, 07 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/03/07/c-ep23-if-constexpt/</guid>
      <description>以 if constexpr 开始的语句被称为 constexpr if 语句，从 c++17 起支持。在 constexpr if 语句中，条件的值必须能语境地转换到 bool 类型的 *常量表达式*。其值为 true，则舍去 false 分支语句</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep22: Fibonacci</title>
      <link>https://hardy5012.github.io/2018/02/28/c-ep22-fibonacci/</link>
      <pubDate>Wed, 28 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/02/28/c-ep22-fibonacci/</guid>
      <description>Fibonacci(斐波那契数)的特点是每一个数都是前二个数的和.以下测试都使用第 45 个值。 递归版本 1 2 3 4 5 6 7 int fib(const int i) { if(i == 0) return 0; if(i == 1) return</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep21: variadic Templates</title>
      <link>https://hardy5012.github.io/2018/02/21/c-ep21-variadic-templates/</link>
      <pubDate>Wed, 21 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/02/21/c-ep21-variadic-templates/</guid>
      <description>使用 之前 在使用可变参数模板之前，如果有几个参数，就需要对应的模块。 1 2 3 4 5 6 7 //一个参数 template&amp;lt;typename T1&amp;gt; //两个参数 template&amp;lt;typename T1, typename T2&amp;gt; //三个参数 template&amp;lt;typename T1, typename T2, typename T3&amp;gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep20: Static Variable</title>
      <link>https://hardy5012.github.io/2018/02/13/c-ep20-static-variable/</link>
      <pubDate>Tue, 13 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/02/13/c-ep20-static-variable/</guid>
      <description>C++ static 变量 初始化顺序 全局变量、文件域的 static 变量和类的 static 成员变量在 main 函数执行之前初始化 局部静态变量在第一次被使用时初始化 线程安全 从 C++ 11 起局部静态变</description>
    </item>
    
    <item>
      <title>Tweaks(2)</title>
      <link>https://hardy5012.github.io/2018/02/06/tweaks2/</link>
      <pubDate>Tue, 06 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/02/06/tweaks2/</guid>
      <description>Item 42:考虑就地创建而非插入 如果你有一个容器，比如说 std::strings，将 std::string 元素类型传给插入函数(如, insert, push_front, push_back, 或是, for std::forward_list, insert_a</description>
    </item>
    
    <item>
      <title>Tweaks(1)</title>
      <link>https://hardy5012.github.io/2018/02/05/tweaks1/</link>
      <pubDate>Mon, 05 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/02/05/tweaks1/</guid>
      <description>Item 41:对于那些移动廉价总是被拷贝的形参使用传值方式 有些函数参数是要复制的。(在这个项目中，“复制”参数通常意味着将其用作复制或移动操作的来</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep19:The Concurrency API(4)</title>
      <link>https://hardy5012.github.io/2018/02/02/c-ep19the-concurrency-api4/</link>
      <pubDate>Fri, 02 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/02/02/c-ep19the-concurrency-api4/</guid>
      <description>Item40: 对于并发使用 std :: atomic，对特殊的内存使用 volatile 一旦构建了一个 std::atomic 对象，对它的操作就好像它们在一个受互斥体保护的临界区域内一样，但是操作通常</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep18:The Concurrency API(3)</title>
      <link>https://hardy5012.github.io/2018/01/30/c-ep18the-concurrency-api3/</link>
      <pubDate>Tue, 30 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/01/30/c-ep18the-concurrency-api3/</guid>
      <description>Item39:考虑使用 void futures 一次性事件通信 ​有的时候对于一个任务来说，希望有一种机制可以和另外一个任务进行通信，尤其是那种异步运行的任务，并且</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep17:The Concurrency API(2)</title>
      <link>https://hardy5012.github.io/2018/01/17/c-ep17the-concurrency-api2/</link>
      <pubDate>Wed, 17 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/01/17/c-ep17the-concurrency-api2/</guid>
      <description>Item 37:让 std::thread 对象在所有路径都无法连接 每个 std::thread 对象的状态都是这两种中的一种：joinable（可连接的）或 unjoinable（不可连接的）。一</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep16:The Concurrency API(1)</title>
      <link>https://hardy5012.github.io/2018/01/15/c-ep16the-concurrency-api1/</link>
      <pubDate>Mon, 15 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/01/15/c-ep16the-concurrency-api1/</guid>
      <description>Item 35:优先考虑基于任务编程，而不是线程编程 如果你想异步地运行函数 doAsyncWork，你有两个基本的选择。你可以创建一个 std::thr</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep15:Lambda Epressions(2)</title>
      <link>https://hardy5012.github.io/2018/01/14/c-ep15lambda-epressions2/</link>
      <pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/01/14/c-ep15lambda-epressions2/</guid>
      <description>Item 33:对需要 std::forward 的 auto&amp;amp;&amp;amp;参数使用 decltype 泛型 lambda(generic lambda)是 C++14 最令人兴奋的特性之一——lambda 可以在参数说明中使用 au</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep14:Lambda Epressions(1)</title>
      <link>https://hardy5012.github.io/2018/01/11/c-ep14lambda-epressions1/</link>
      <pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/01/11/c-ep14lambda-epressions1/</guid>
      <description>Item31:对于 lambda 表达式，避免使用默认捕获模式 C++11 中有两种默认捕获模式：引用捕获或值捕获。默认的引用捕获模式可能会导致悬挂引用，默认的值捕获</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep13:Rvalue References,Move Semantics,and Perfect Forwarding(5)</title>
      <link>https://hardy5012.github.io/2018/01/09/c-ep13rvalue-referencesmove-semanticsand-perfect-forwarding5/</link>
      <pubDate>Tue, 09 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/01/09/c-ep13rvalue-referencesmove-semanticsand-perfect-forwarding5/</guid>
      <description>Item 30:熟悉完美转发失败的情况 完美转发是 C++11 箱子里最令人注目的特性之一，完美转发，它是完美的！额，打开箱子后，然后你会发现理想中的“完美”和现</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep12:Rvalue References,Move Semantics,and Perfect Forwarding(4)</title>
      <link>https://hardy5012.github.io/2018/01/07/c-ep12rvalue-referencesmove-semanticsand-perfect-forwarding4/</link>
      <pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/01/07/c-ep12rvalue-referencesmove-semanticsand-perfect-forwarding4/</guid>
      <description>Item 28:理解引用折叠 Item 23 说过，当一个参数被传给模板函数时，不管这个参数是左值还是右值，模板参数的类型推导都会对参数进行编码。 那个 Item 没有解释这</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep11:Rvalue References,Move Semantics,and Perfect Forwarding(3)</title>
      <link>https://hardy5012.github.io/2018/01/05/c-ep11rvalue-referencesmove-semanticsand-perfect-forwarding3/</link>
      <pubDate>Fri, 05 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/01/05/c-ep11rvalue-referencesmove-semanticsand-perfect-forwarding3/</guid>
      <description>Item 27:明白什么时候选择重载，什么时候选择 universal 引用 Item 26 已经解释了，不管是对全局函数还是成员函数（尤其是构造函数）而言，对 universal 引用的重载会导致一系</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep10:Rvalue References,Move Semantics,and Perfect Forwarding(2)</title>
      <link>https://hardy5012.github.io/2018/01/04/c-ep10rvalue-referencesmove-semanticsand-perfect-forwarding2/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/01/04/c-ep10rvalue-referencesmove-semanticsand-perfect-forwarding2/</guid>
      <description>Item 25:对右值引用使用 std::move，对 universal 引用则使用 std::forward 右值引用只能绑定那些有资格被 move 的对象上去。如果你有一个右值引用类型的参数，你就知道</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep08:Smart Pointers(3)</title>
      <link>https://hardy5012.github.io/2018/01/03/c-ep08smart-pointers3/</link>
      <pubDate>Wed, 03 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/01/03/c-ep08smart-pointers3/</guid>
      <description>Item 22:当使用 Pimpl 机制时，在实现文件中给出特殊成员函数的实现 如果你曾经同过久的编译时间斗争过，那么你肯定对 Pimpl（&amp;#34;point to i</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep09:Rvalue References,Move Semantics,and Perfect Forwarding(1)</title>
      <link>https://hardy5012.github.io/2018/01/03/c-ep09rvalue-referencesmove-semanticsand-perfect-forwarding1/</link>
      <pubDate>Wed, 03 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/01/03/c-ep09rvalue-referencesmove-semanticsand-perfect-forwarding1/</guid>
      <description>Item 23:理解 std::move 和 std::forward 根据 std::move 和 std::forward 不能做什么来熟悉它们是一个好办法。std::move 没有 move 任何东西，std::forward 没有转发任何东西。 在</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep07:Smart Pointers(2)</title>
      <link>https://hardy5012.github.io/2018/01/02/c-ep07smart-pointers2/</link>
      <pubDate>Tue, 02 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2018/01/02/c-ep07smart-pointers2/</guid>
      <description>Item 20:使用 std::weak_ptr 替换会造成指针悬挂的 std::shared_ptr-like 指针 矛盾的是，我们很容易就能创造出一个和 std::shared_ptr 类似的智能指针，但是，它们不参加被指向资源的共享所有权管理。 换</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep06:Smart Pointers(1)</title>
      <link>https://hardy5012.github.io/2017/12/29/c-_ep06_smart_pointers_1/</link>
      <pubDate>Fri, 29 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/12/29/c-_ep06_smart_pointers_1/</guid>
      <description>item 18: 使用 std::unique_ptr 来管理独占所有权的资源 当你需要一个智能指针的时候，std::unique_ptr 通常是最接近你需求的那一个。默认情况下，这么假设是</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep05:Moving to Modern C&#43;&#43;(3)</title>
      <link>https://hardy5012.github.io/2017/12/27/c-ep05moving-to-modern-c-3/</link>
      <pubDate>Wed, 27 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/12/27/c-ep05moving-to-modern-c-3/</guid>
      <description>item 15: 只要有可能，就使用 constexpr 从概念上来说，constexpr 表明的一个值不只是不变的，它还能在编译期被知道。但是这个概念只是故事的一部分，因为当</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep04:Moving to Modern C&#43;&#43;(2)</title>
      <link>https://hardy5012.github.io/2017/12/26/c-ep04moving-to-modern-c-2/</link>
      <pubDate>Tue, 26 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/12/26/c-ep04moving-to-modern-c-2/</guid>
      <description>item 11: 优先考虑使用 deleted function 而非 private undefined 在 C++ 98 中禁止拷贝和赋值实现如下： 1 2 3 4 5 6 7 8 template &amp;lt;classcharT, classtraits = char_traits&amp;lt;charT&amp;gt; &amp;gt; classbasic_ios : public ios_base { public: … private: basic_ios(const basic_ios&amp;amp; ); // not defined basic_ios&amp;amp; operator=(const basic_ios&amp;amp;); // not defined }; In C++1</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep03:Moving to Modern C&#43;&#43;(1)</title>
      <link>https://hardy5012.github.io/2017/12/22/c-ep03moving-to-modern-c-1/</link>
      <pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/12/22/c-ep03moving-to-modern-c-1/</guid>
      <description>item 7: 区别使用（）和{}创建对象 记住 括号初始化是最广泛使用的初始化语法，它防止变窄转换（narrowing conversion，并且对于 C++</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep02:auto</title>
      <link>https://hardy5012.github.io/2017/12/21/c-ep02auto/</link>
      <pubDate>Thu, 21 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/12/21/c-ep02auto/</guid>
      <description>item 5: 尽量用 auto 代替显式类型声明 1 2 3 4 5 6 std::unordered_map&amp;lt;std::string, int&amp;gt; m; … for (const std::pair&amp;lt;std::string, int&amp;gt;&amp;amp; p : m) { … // do something with p } 上面代码看起来很完美，但是有个问题。std::unordere</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep01:模板类型推导</title>
      <link>https://hardy5012.github.io/2017/12/18/c-ep01%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</link>
      <pubDate>Mon, 18 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/12/18/c-ep01%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</guid>
      <description>Case 1:ParmaType 是引用或指针，但不是 Universal Referencs 如果 expr 类型是一个引用，忽略引用部分 expr 的类型和 ParamType 模式匹配的部分决定了 T 示例模板： 1 2 template&amp;lt;typename T&amp;gt; void f(T&amp;amp; param); // param is a reference 变量定义：</description>
    </item>
    
    <item>
      <title>centos7 配置 service</title>
      <link>https://hardy5012.github.io/2017/12/07/centos7%E9%85%8D%E7%BD%AEservice/</link>
      <pubDate>Thu, 07 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/12/07/centos7%E9%85%8D%E7%BD%AEservice/</guid>
      <description>配置 service 文件 在/usr/lib/systemd/system/目录创建自己的 service 文件 my.service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29</description>
    </item>
    
    <item>
      <title>python 协程</title>
      <link>https://hardy5012.github.io/2017/11/26/python%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Sun, 26 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/11/26/python%E5%8D%8F%E7%A8%8B/</guid>
      <description>协程 协程是一种用户态的轻量级线程，因为是非抢占式的，所以协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上</description>
    </item>
    
    <item>
      <title>linux 环境</title>
      <link>https://hardy5012.github.io/2017/11/16/linux%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 16 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/11/16/linux%E7%8E%AF%E5%A2%83/</guid>
      <description>翻墙 ssh 1 sudo ssh -qTfnN -D 8087 user@remote-hosts 上面的 8087 是本地未被占用的端口，可以自己选择。其它参数的意思是： -q :- be very quite, we are acting only as a tunnel. -T :- Do not allocate a pseudo tty, we are only acting a tunnel. -f :- move</description>
    </item>
    
    <item>
      <title>HeroKu</title>
      <link>https://hardy5012.github.io/2017/06/07/2017-06-07-heroku/</link>
      <pubDate>Wed, 07 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/06/07/2017-06-07-heroku/</guid>
      <description>安装 1 2 3 4 5 sudo yum install ruby gem sudo gem install json_pure sudo gem install rails sudo gem install bundler sudo gem install heroku {{{more}}}</description>
    </item>
    
    <item>
      <title>Python 虚拟环境</title>
      <link>https://hardy5012.github.io/2017/06/06/2017-06-06-python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Tue, 06 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/06/06/2017-06-06-python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</guid>
      <description>Virtualenv Introduction virtualenv is a tool to create isolated Python environments. Installation 1 sudo pip install virtualenv {{{more}}} Usage 1.为一个工程创建一个虚拟环境： 1 2 cd my_project_folder virtualenv venv virtualenv venv 将会在当前的目录中创建一个文件夹，包含了 Python 可执行文件，</description>
    </item>
    
    <item>
      <title>Machine Learning(4) Regularization</title>
      <link>https://hardy5012.github.io/2017/05/17/machine-learning4-regularization/</link>
      <pubDate>Wed, 17 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/05/17/machine-learning4-regularization/</guid>
      <description>正规化(Regularization)弱化的高阶项的系数，这弱化也称为对参数θ的惩罚（penalize）。 线性回归中的正规化 公式变为： \begin{gather*} J(</description>
    </item>
    
    <item>
      <title>octave</title>
      <link>https://hardy5012.github.io/2017/05/11/2017-05-11-octave/</link>
      <pubDate>Thu, 11 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/05/11/2017-05-11-octave/</guid>
      <description>矩阵与标量＝＝运算，对矩阵所有值与标量进行判断，如果相等则为 1，不等则为 0 {{{more}}}</description>
    </item>
    
    <item>
      <title>Machine Learning(3) Neural Networks</title>
      <link>https://hardy5012.github.io/2017/05/07/2017-05-07-machine-learning%E4%B8%89-neural-networks/</link>
      <pubDate>Sun, 07 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/05/07/2017-05-07-machine-learning%E4%B8%89-neural-networks/</guid>
      <description>Model Representation  \text {If network has $s_j$ units in layer $j$ and $sj+1$ units in layer $j+1$, then $Θ(j)$ will be of dimension $sj+1 × (s_j + 1)$.}  Cost Function   Let&amp;#39;s first define a few variables that we will need to use: L = total number of layers in the network $s_l$ = number of units (not counting bias unit) in layer l K = number of output units/classes   \begin{gather*} J(Θ) = - \frac{1}{m} ∑i=1^m ∑k=1^K ≤ft[y(i)_k log ((h_Θ (x(i)))_k) + (1 - y(i)_k)log (1 - (h_Θ(x(i)))_k)\right] + \frac{λ}{2m}∑l=1L-1 ∑i=1s_l ∑j=1^{sl+1} ( Θj,i(l))^2\end{gather*} Gradient Checking   Gradient checking will assure that our backpropagation works as intended.</description>
    </item>
    
    <item>
      <title>Machine Learning(2）Logistic Regression</title>
      <link>https://hardy5012.github.io/2017/04/27/2017-04-27-machine-learing%E4%BA%8C-logistic-regression/</link>
      <pubDate>Thu, 27 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/04/27/2017-04-27-machine-learing%E4%BA%8C-logistic-regression/</guid>
      <description>Decision Boundary 决策边界(Decison Boundary)就是用来划清界限的边界，即属于哪一类。 “决策边界是预测函数$h_θ(x)$ 的属性，而不是训练集</description>
    </item>
    
    <item>
      <title>Machine Learning(1)Linear Regression</title>
      <link>https://hardy5012.github.io/2017/04/21/2017-04-21-maching-learing-normal-equation/</link>
      <pubDate>Fri, 21 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/04/21/2017-04-21-maching-learing-normal-equation/</guid>
      <description>Hypothesis $$ h_θ(x)=θ_0+θ_1x_1+θ_2x_2+…+θ_nx_n=θ^Tx $$ Cost Function $$ J(θ)=\frac{1}{2m}∑limitsi=</description>
    </item>
    
    <item>
      <title>Machine Learning(0) introduction</title>
      <link>https://hardy5012.github.io/2017/04/13/machine-learning0-introduction/</link>
      <pubDate>Thu, 13 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/04/13/machine-learning0-introduction/</guid>
      <description>Supervised Learning and Unsupevised Learning 监督学习（Supervised Learning）所给的样本已知道正确的输出是什么样子，对输入与输出有一定的了解。 无监督学习（Uns</description>
    </item>
    
    <item>
      <title>makefile</title>
      <link>https://hardy5012.github.io/2017/03/02/2017-04-25-makefile/</link>
      <pubDate>Thu, 02 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2017/03/02/2017-04-25-makefile/</guid>
      <description>undefined reference 问题 多个库文件连接顺序问题 在链接命令中给出所依赖的库时，需要注意库之间的依赖顺序，依赖其他库的库一定要放到被依赖库的前面，这样才能真正避</description>
    </item>
    
    <item>
      <title>ETF notes</title>
      <link>https://hardy5012.github.io/2016/11/28/2016-11-28-etf-notes/</link>
      <pubDate>Mon, 28 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2016/11/28/2016-11-28-etf-notes/</guid>
      <description>预估现金 预估现金是每一个最小申购单位的资产值减去今天公布出来的清单中所有股票用前收价算出来的价值之间的差额 预估现金为负时，篮子清单市值偏多（</description>
    </item>
    
    <item>
      <title>python notes</title>
      <link>https://hardy5012.github.io/2016/11/16/2016-11-16-python-notes/</link>
      <pubDate>Wed, 16 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2016/11/16/2016-11-16-python-notes/</guid>
      <description>yield yield 为生成器，有调用 next 或 send 来取值（只有调用这两个函数才会运行） 在 yield 处返回数据，用 send 来发送数据到程序内 1 2 3 4 5 6 7 8 9 10 11 12 13 def h(): print &amp;#39;Wen Chuan&amp;#39;, m =</description>
    </item>
    
    <item>
      <title>learning boost</title>
      <link>https://hardy5012.github.io/2016/11/03/2016-11-03-learning-boost/</link>
      <pubDate>Thu, 03 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2016/11/03/2016-11-03-learning-boost/</guid>
      <description>MSM 执行顺序: start state on_exit -&amp;gt; action -&amp;gt; next state on_entry 状态转换判断顺序： 按转表换插入的反序来判断，即在从转换表后面开始判断,同样满足条件的，执行后面 事件只能激活子状</description>
    </item>
    
    <item>
      <title>性能分析</title>
      <link>https://hardy5012.github.io/2016/09/05/2016-09-05-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 05 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2016/09/05/2016-09-05-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</guid>
      <description>c++ 程序性能分析 环境准备 安装 graphviz 1 sudo yum install graphviz.x86_64 安装 gprof2dot 1 sudo pip install gprof2dot 在 makefile 中增加 -pg 参数 导出图片 1 gprof 程序名 gmon.out|gprof2dot -s | dot -Tpng -o output.png gprof2dot 后面带参数-s 是简化函数名 {{{more}}}</description>
    </item>
    
    <item>
      <title>编程小记</title>
      <link>https://hardy5012.github.io/2016/08/13/2016-08-13-%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Sat, 13 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2016/08/13/2016-08-13-%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0/</guid>
      <description>ProtoBuf c++ protobuf 对 inner class 的修改，使用 mutable 来获取 inner class 指针 {{{more}}} SVN 一次添加所有文件 svn st | awk &amp;#39;{if ( $1 == &amp;#34;?&amp;#34;) { print $2}}&amp;#39; | xargs svn add linux clean cache 仅清除页面缓存（PageCache） 1 sync; echo</description>
    </item>
    
    <item>
      <title>配置多个 git 账户</title>
      <link>https://hardy5012.github.io/2016/07/26/2016-07-26-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgithub/</link>
      <pubDate>Tue, 26 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2016/07/26/2016-07-26-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgithub/</guid>
      <description>配置多个 git 账户 在使用 ssh keys 时常因为有多个 git 账户，无法正常使用 {{{more}}} 生成 SSH keys 1 ssh-keygen -t rsa -f ~/.ssh/id_github -C &amp;#34;youremail@xxx.com&amp;#34; 在 Git Bash 中执行命令根据提示一路回车，会在~/.ssh/目录</description>
    </item>
    
    <item>
      <title>学习 Spacemacs</title>
      <link>https://hardy5012.github.io/2016/07/22/2016-07-22-test/</link>
      <pubDate>Fri, 22 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hardy5012.github.io/2016/07/22/2016-07-22-test/</guid>
      <description>安装 下载，最新下载地址 http://ftpmirror.gnu.org/emacs/emacs-25.2.tar.xz 安装 1 2 3 4 sudo yum -y install libXpm-devel libjpeg-turbo-devel openjpeg-devel openjpeg2-devel turbojpeg-devel giflib-devel libtiff-devel gnutls-devel libxml2-devel GConf2-devel dbus-devel wxGTK-devel gtk3-devel ./configure make sudo make install 常用快捷键 vi normal r, R: r 修改当个字符，R 则会进入一种 overwrite 模式，可以</description>
    </item>
    
  </channel>
</rss>