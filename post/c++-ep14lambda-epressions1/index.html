<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.57.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>C&#43;&#43; Ep14:Lambda Epressions(1) | Learning Hardy</title>
    <meta property="og:title" content="C&#43;&#43; Ep14:Lambda Epressions(1) - Learning Hardy">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2018-01-11T00:00:00&#43;08:00">
        
        
    <meta property="article:modified_time" content="2018-01-11T00:00:00&#43;08:00">
        
    <meta name="Keywords" content="">
    <meta name="description" content="C&#43;&#43; Ep14:Lambda Epressions(1)">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://hardy5012.github.io/post/c&#43;&#43;-ep14lambda-epressions1/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://hardy5012.github.io/">
                        Learning Hardy
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://hardy5012.github.io/">首页</a>
                    
                    <a  href="https://hardy5012.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://hardy5012.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">C&#43;&#43; Ep14:Lambda Epressions(1)</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2018年1月11日
                        </date>
                        
                        <div class="post-meta">
                            <span>|</span>
                            
                                <span class="meta-category"><a href="https://hardy5012.github.io/categories/modern">Modern</a></span>
                            
                                <span class="meta-category"><a href="https://hardy5012.github.io/categories/c&#43;&#43;">C&#43;&#43;</a></span>
                            
                        </div>
                        
                        
                        
                        <div class="post-content">
                            
<h1 id="headline-1">
Item31:对于 lambda 表达式，避免使用默认捕获模式
</h1>
<p>
C++11 中有两种默认捕获模式：引用捕获或值捕获。默认的引用捕获模式可能会导致悬挂引用，默认的值捕获模式诱骗你——让你认为你可以免疫刚说的问题（事实上没有免疫），
然后它又骗你——让你认为你的闭包是独立的（事实上它们可能不是独立的）
</p>
<!-- more -->
<p>
那就是本条款的总纲。如果你是工程师，你会想要更具体的内容，所以让我们从默认捕获模式的危害开始说起吧。
</p>
<p>
引用捕获会导致闭包包含一个局部变量的引用或者一个形参的引用（在定义 lamda 的作用域）。如果一个由 lambda 创建的闭包的生命期超过了局部变量或者形参的生命期，
那么闭包的引用将会空悬。例如，我们有一个容器，它的元素是过滤函数，这种过滤函数接受一个 int，返回 bool 表示传入的值是否可以满足过滤条件：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">using</span> FilterContainer <span style="color:#f92672">=</span> <span style="color:#75715e">// see Item 9 for
</span><span style="color:#75715e"></span>	  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;&gt;</span>; <span style="color:#75715e">// &#34;using&#34;, Item 2
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// for std::function
</span><span style="color:#75715e"></span>  FilterContainer filters; <span style="color:#75715e">// filtering funcs
</span></code></pre></div>
</div>
<p>
我们可以通过添加一个过滤器，过滤掉 5 的倍数，像这样：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  filters.emplace_back( <span style="color:#75715e">// see Item 42 for
</span><span style="color:#75715e"></span>	  [](<span style="color:#66d9ef">int</span> value) { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; } <span style="color:#75715e">// info on
</span><span style="color:#75715e"></span>	  ); <span style="color:#75715e">// emplace_back
</span></code></pre></div>
</div>
<p>
但是，我们可能需要在运行期间计算被除数，而不是直接把硬编码 5 写到 lambda 中，所以添加过滤器的代码可能是这样的：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addDivisorFilter</span>()
  {
	  <span style="color:#66d9ef">auto</span> calc1 <span style="color:#f92672">=</span> computeSomeValue1();
	  <span style="color:#66d9ef">auto</span> calc2 <span style="color:#f92672">=</span> computeSomeValue2();
	  <span style="color:#66d9ef">auto</span> divisor <span style="color:#f92672">=</span> computeDivisor(calc1, calc2);
	  filters.emplace_back( <span style="color:#75715e">// danger!
</span><span style="color:#75715e"></span>		  [<span style="color:#f92672">&amp;</span>](<span style="color:#66d9ef">int</span> value) { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> divisor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; } <span style="color:#75715e">// ref to
</span><span style="color:#75715e"></span>		  ); <span style="color:#75715e">// divisor
</span><span style="color:#75715e"></span>  } <span style="color:#75715e">// will
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// dangle!
</span></code></pre></div>
</div>
<p>
这代码有个定时炸弹。lambda 引用了局部变量 divisor， 但是局部变量的生命期在 addDivisorFilter 返回时终止，也就是在 filters.emplace_back 返回之后，
所以添加到容器的函数本质上就像是一到达容器就死亡了。使用那个过滤器会产生未定义行为，这实际上是在创建过滤器的时候就决定好的了。
</p>
<p>
现在呢，如果显式引用捕获 divisor，会存在着同样的问题：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  filters.emplace_back(
	  [<span style="color:#f92672">&amp;</span>divisor](<span style="color:#66d9ef">int</span> value) <span style="color:#75715e">// danger! ref to
</span><span style="color:#75715e"></span>	  { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> divisor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; } <span style="color:#75715e">// divisor will
</span><span style="color:#75715e"></span>	  ); <span style="color:#75715e">// still dangle!
</span></code></pre></div>
</div>
<p>
不过使用显示捕获，很容易就可以看出 lambda 的活性依赖于 divisor 的生命期。而且，写出名字“divisor”会提醒我们，
要确保 divisor 的生命期至少和 lambda 闭包一样长。比起用“[&amp;]”表达“确保不会空悬”，显式捕获更容易让你想起这个告诫。
</p>
<p>
如果你知道一个闭包创建后马上被使用（例如，传递给 STL 算法）而且不会被拷贝，那么引用的局部变量或参数就没有风险。
在这种情况下，你可能会争论，没有空悬引用的风险，因此没有理由避免使用默认的引用捕获模式，
例如，我们的过滤 lambda 只是作为 C++11 的 std::all_of 的参数（std::all_of 返回范围内元素是否都满足某个条件）：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> C<span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">void</span> workWithContainer(<span style="color:#66d9ef">const</span> C<span style="color:#f92672">&amp;</span> container)
  {
	  <span style="color:#66d9ef">auto</span> calc1 <span style="color:#f92672">=</span> computeSomeValue1(); <span style="color:#75715e">// as above
</span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">auto</span> calc2 <span style="color:#f92672">=</span> computeSomeValue2(); <span style="color:#75715e">// as above
</span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">auto</span> divisor <span style="color:#f92672">=</span> computeDivisor(calc1, calc2); <span style="color:#75715e">// as above
</span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">using</span> ContElemT <span style="color:#f92672">=</span> <span style="color:#66d9ef">typename</span> C<span style="color:#f92672">::</span>value_type; <span style="color:#75715e">// type of
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// elements in
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// container
</span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>begin; <span style="color:#75715e">// for
</span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>end; <span style="color:#75715e">// genericity;
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// see Item 13
</span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">if</span> (std<span style="color:#f92672">::</span>all_of( <span style="color:#75715e">// if all values
</span><span style="color:#75715e"></span>			  begin(container), end(container), <span style="color:#75715e">// in container
</span><span style="color:#75715e"></span>			  [<span style="color:#f92672">&amp;</span>](<span style="color:#66d9ef">const</span> ContElemT<span style="color:#f92672">&amp;</span> value) <span style="color:#75715e">// are multiples
</span><span style="color:#75715e"></span>			  { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> divisor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; }) <span style="color:#75715e">// of divisor...
</span><span style="color:#75715e"></span>		  ) {
		  <span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// they are...
</span><span style="color:#75715e"></span>			  } <span style="color:#66d9ef">else</span> {
		  <span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// at least one
</span><span style="color:#75715e"></span>			  } <span style="color:#75715e">// isn&#39;t...
</span><span style="color:#75715e"></span>  }
</code></pre></div>
</div>
<p>
当然，这是安全的，但是它的安全有点不稳定，如果发现 lambda 在其他上下文很有用（例如，作为函数加入到过滤器容器），然后拷贝及粘贴到其他上下文，
在那里 divisor 已经死亡，而闭包还健全，你又回到了空悬的境地，同时，在捕获语句中，也没有特别提醒你对 divisor 进行生命期分析（即没有显式捕获）。
</p>
<p>
从长期来看，显式列出 lambda 依赖的局部变量或形参是更好的软件工程。
</p>
<p>
顺便说下，C++14 的 lambda 形参可以使用 auto 声明，意味着上面的代码可以用 C++14 简化，ContElemT 的那个 typedef 可以删去，
然后把 if 语句的条件改成这样：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">if</span> (std<span style="color:#f92672">::</span>all_of(begin(container), end(container),
				  [<span style="color:#f92672">&amp;</span>](<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> value) <span style="color:#75715e">// C++14
</span><span style="color:#75715e"></span>				  { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> divisor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; }))
</code></pre></div>
</div>
<p>
解决这个问题的一种办法是对 divisor 使用默认的值捕获模式。即，我们这样向容器添加 lambda：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  filters.emplace_back( <span style="color:#75715e">// now
</span><span style="color:#75715e"></span>	  [<span style="color:#f92672">=</span>](<span style="color:#66d9ef">int</span> value) { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> divisor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; } <span style="color:#75715e">// divisor
</span><span style="color:#75715e"></span>	  ); <span style="color:#75715e">// can&#39;t
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// dangle
</span></code></pre></div>
</div>
<p>
这满足这个例子的需要，但是，总的来说，默认以值捕获不是对抗空悬的长生不老药。问题在于，如果你用值捕获了个指针，
你在 lambda 创建的闭包中持有这个指针的拷贝，但你不能阻止 lambda 外面的代码删除指针指向的内容，从而导致你拷贝的指针空悬。
</p>
<p>
“这不可能发生”你在抗议，“自从看了第四章，我十分热爱智能指针。只有智障的 C++98 程序员才会使用原生指针和 delete。
”你说的可能是正确的，但这是不相关的，因为实际上你真的会使用原生指针，而它们实际上也会在你眼皮底下被删除，只不过在你的现代 C++编程风格中，
它们（原生指针）在源代码中不露迹象。。
</p>
<p>
假如 Widget 类可以做的其中一件事是，向过滤器容器添加条目：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">Widget</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// ctors, etc.
</span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">void</span> addFilter() <span style="color:#66d9ef">const</span>; <span style="color:#75715e">// add an entry to filters
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	  <span style="color:#66d9ef">int</span> divisor; <span style="color:#75715e">// used in Widget&#39;s filter
</span><span style="color:#75715e"></span>  };
</code></pre></div>
</div>
<p>
Widget::addFilter 可能定义成这样：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">void</span> Widget<span style="color:#f92672">::</span>addFilter() <span style="color:#66d9ef">const</span>
  {
	  filters.emplace_back(
		  [<span style="color:#f92672">=</span>](<span style="color:#66d9ef">int</span> value) { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> divisor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; }
		  );
  }
</code></pre></div>
</div>
<p>
对于外行人，这看起来像是安全的代码。lambda 依赖 divisor，但默认的以值捕获模式确保了 divisor 被拷贝到 lambda 创建的闭包里，对吗？
</p>
<p>
错了，完全错了。
</p>
<p>
<span style="text-decoration: underline;">捕获只能用于可见（在创建 lambda 的作用域可见）的非 static 局部变量（包含形参）</span> 。在 Widget::addFilter 内部，
divisor 不是局部变量，它是 Widget 类的成员变量，它是不能被捕获的，如果默认捕获模式被删除，代码就不能编译了：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">void</span> Widget<span style="color:#f92672">::</span>addFilter() <span style="color:#66d9ef">const</span>
  {
	  filters.emplace_back( <span style="color:#75715e">// error!
</span><span style="color:#75715e"></span>		  [](<span style="color:#66d9ef">int</span> value) { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> divisor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; } <span style="color:#75715e">// divisor
</span><span style="color:#75715e"></span>		  ); <span style="color:#75715e">// not
</span><span style="color:#75715e"></span>  } <span style="color:#75715e">// available
</span></code></pre></div>
</div>
<p>
而且，如果试图显式捕获 divisor（无论是值捕获还是引用捕获，这都没有关系），捕获不会通过编译，因为 divisor 不是局部变量或形参：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">void</span> Widget<span style="color:#f92672">::</span>addFilter() <span style="color:#66d9ef">const</span>
  {
	  filters.emplace_back(
		  [divisor](<span style="color:#66d9ef">int</span> value) <span style="color:#75715e">// error! no local
</span><span style="color:#75715e"></span>		  { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> divisor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; } <span style="color:#75715e">// divisor to capture
</span><span style="color:#75715e"></span>		  );
  }
</code></pre></div>
</div>
<p>
所以如果在默认值捕获语句中（即“[=]”），捕获的不是 divisor，而不是默认值捕获语句就不能编译，那么前者发生了什么？
</p>
<p>
问题解释取决于原生指针的隐式使用： <strong>this</strong> 。每一个非 static 成员函数都有一个 this 指针，然后每当你使用类的成员变量时都用到这个指针。
例如，在 Widget 的一些成员函数中，编译器内部会把 divisor 替换成 this-&gt;divisor。在 Widget::addFiliter 的默认值捕获版本中，
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">void</span> Widget<span style="color:#f92672">::</span>addFilter() <span style="color:#66d9ef">const</span>
  {
	  filters.emplace_back(
		  [<span style="color:#f92672">=</span>](<span style="color:#66d9ef">int</span> value) { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> divisor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; }
		  );
  }
</code></pre></div>
</div>
<p>
被捕获的是 Widget 的 this 指针，而不是 divisor，编译器把上面的代码视为这样写的：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">void</span> Widget<span style="color:#f92672">::</span>addFilter() <span style="color:#66d9ef">const</span>
  {
	  <span style="color:#66d9ef">auto</span> currentObjectPtr <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>;
	  filters.emplace_back(
		  [currentObjectPtr](<span style="color:#66d9ef">int</span> value)
		  { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> currentObjectPtr<span style="color:#f92672">-&gt;</span>divisor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; }
		  );
  }
</code></pre></div>
</div>
<p>
理解了这个就相当于理解了 lambda 闭包的活性与 Widget 对象的生命期有紧密关系，闭包内含有 Widget 的 this 指针的拷贝。
特别是，思考下面的代码，它根据第 4 章，只是用智能指针：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">using</span> FilterContainer <span style="color:#f92672">=</span> <span style="color:#75715e">// as before
</span><span style="color:#75715e"></span>	  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;&gt;</span>;
  FilterContainer filters; <span style="color:#75715e">// as before
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doSomeWork</span>()
  {
	  <span style="color:#66d9ef">auto</span> pw <span style="color:#f92672">=</span> <span style="color:#75715e">// create Widget; see
</span><span style="color:#75715e"></span>		  std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>(); <span style="color:#75715e">// Item 21 for
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// std::make_unique
</span><span style="color:#75715e"></span>	  pw<span style="color:#f92672">-&gt;</span>addFilter(); <span style="color:#75715e">// add filter that uses
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Widget::divisor
</span><span style="color:#75715e"></span>	  <span style="color:#960050;background-color:#1e0010">…</span>
		  } <span style="color:#75715e">// destroy Widget; filters
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// now holds dangling pointer!
</span></code></pre></div>
</div>
<p>
当调用 doSomeWork 时，创建了一个过滤函数，它依赖 std::make_unique 创建的 Widget 对象，即，那个过滤函数内含有指向 Widget 指针——即，
Widget 的 this 指针——的拷贝。这个函数被添加到 filters 中，不过当 doSomeWork 执行结束之后，Widget 对象被销毁，
因为它的生命期由 std::unique_ptr 管理（看条款 18）。从那一刻起，filters 中含有一个带空悬指针的条目。
</p>
<p>
通过将你想捕获的成员变量拷贝到局部变量中，然后捕获这个局部拷贝，就可以解决这个特殊的问题了：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">void</span> Widget<span style="color:#f92672">::</span>addFilter() <span style="color:#66d9ef">const</span>
  {
	  <span style="color:#66d9ef">auto</span> divisorCopy <span style="color:#f92672">=</span> divisor; <span style="color:#75715e">// copy data member
</span><span style="color:#75715e"></span>	  filters.emplace_back(
		  [divisorCopy](<span style="color:#66d9ef">int</span> value) <span style="color:#75715e">// capture the copy
</span><span style="color:#75715e"></span>		  { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> divisorCopy <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; } <span style="color:#75715e">// use the copy
</span><span style="color:#75715e"></span>		  );
  }
</code></pre></div>
</div>
<p>
实话说，如果你用这种方法，那么默认值捕获也是可以工作的
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">void</span> Widget<span style="color:#f92672">::</span>addFilter() <span style="color:#66d9ef">const</span>
  {
	  <span style="color:#66d9ef">auto</span> divisorCopy <span style="color:#f92672">=</span> divisor; <span style="color:#75715e">// copy data member
</span><span style="color:#75715e"></span>	  filters.emplace_back(
		  [<span style="color:#f92672">=</span>](<span style="color:#66d9ef">int</span> value) <span style="color:#75715e">// capture the copy
</span><span style="color:#75715e"></span>		  { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> divisorCopy <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; } <span style="color:#75715e">// use the copy
</span><span style="color:#75715e"></span>		  );
  }
</code></pre></div>
</div>
<p>
但是，我们为什么要冒险呢？在一开始的代码，默认值捕获就意外地捕获了 this 指针，而不是你以为的 divisor。
</p>
<p>
在 C++14 中，捕获成员变量一种更好的方法是使用广义 lambda 捕获（ <strong>generalized lambda capture</strong> ，即，捕获语句可以是表达式，看条款 32）：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">void</span> Widget<span style="color:#f92672">::</span>addFilter() <span style="color:#66d9ef">const</span>
  {
	  filters.emplace_back( <span style="color:#75715e">// C++14:
</span><span style="color:#75715e"></span>		  [divisor <span style="color:#f92672">=</span> divisor](<span style="color:#66d9ef">int</span> value) <span style="color:#75715e">// copy divisor to closure
</span><span style="color:#75715e"></span>		  { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> divisor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; } <span style="color:#75715e">// use the copy
</span><span style="color:#75715e"></span>		  );
  }
</code></pre></div>
</div>
<p>
广义 lambda 捕获没有默认捕获模式，但是，就算在 C++14，本条款的建议——避免使用默认捕获模式——依然成立。
</p>
<p>
使用默认值捕获模式的一个另外的缺点是：它们表明闭包是独立的，不受闭包外数据变化的影响。总的来说，这是不真实的，
因为 lambda 可能不会依赖于局部变量和形参，但它们会依赖于静态存储周期的对象（ <strong>static storage duration</strong> ）。
这样的对象定义在全局作用域或者命名空间作用域，又或者在类中、函数中、文件中声明为 static。这样的对象可以在 lambda 内使用，
但是它们不能被捕获。如果你使用了默认值捕获模式，这些对象会给你错觉，让你认为它们可以捕获。思考下面这个修改版本的 addDivisorFilter 函数：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addDivisorFilter</span>()
  {
	  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">auto</span> calc1 <span style="color:#f92672">=</span> computeSomeValue1(); <span style="color:#75715e">// now static
</span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">auto</span> calc2 <span style="color:#f92672">=</span> computeSomeValue2(); <span style="color:#75715e">// now static
</span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">auto</span> divisor <span style="color:#f92672">=</span> <span style="color:#75715e">// now static
</span><span style="color:#75715e"></span>		  computeDivisor(calc1, calc2);
	  filters.emplace_back(
		  [<span style="color:#f92672">=</span>](<span style="color:#66d9ef">int</span> value) <span style="color:#75715e">// captures nothing!
</span><span style="color:#75715e"></span>		  { <span style="color:#66d9ef">return</span> value <span style="color:#f92672">%</span> divisor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; } <span style="color:#75715e">// refers to above static
</span><span style="color:#75715e"></span>		  );
	  <span style="color:#f92672">++</span>divisor; <span style="color:#75715e">// modify divisor
</span><span style="color:#75715e"></span>  }
</code></pre></div>
</div>
<p>
这份代码，对于随便的读者，他们看到“[=]”然后想，“很好，lambda 拷贝了它内部使用的对象，因此 lambda 是独立的。”，这可以被谅解。
但这 lambda 不是独立的，它没有使用任何的非 static 局部变量和形参，所以它没有捕获任何东西。
更糟的是，lambda 的代码引用了 static 变量 divisor。在每次调用 addDivisorFilter 的最后，divisor 都会被递增，
通过这个函数，会把好多个 lambda 添加到 filiters，每一个 lambda 的行为都是新的（对应新的 divisor 值）。
从实践上讲，这个 lambda 是通过 <span style="text-decoration: underline;">引用捕获 divisor</span> (所以 filiters 中的所有 lambda 都将用的最终的 divisor 进行计算) ，和默认值捕获语句表示的含义有直接的矛盾。
如果你一开始就远离默认的值捕获模式，你就能消除理解错代码的风险。
</p>
<h2 id="headline-2">
记住
</h2>
<ul>
<li>
<p>
默认引用捕获会导致空悬引用。
</p>
</li>
<li>
<p>
默认值捕获对空悬指针（尤其是 this）很敏感，而且它会误导地表明 lambda 是独立
</p>
</li>
</ul>
<h1 id="headline-3">
Item 32:使用初始化捕获来把对象移动到闭包
</h1>
<p>
有时候，你想要的既不是值捕获，也不是引用捕获。如果你想要把一个只可移动对象（例如，std::unique_ptr 或 std::future 类型对象）放入闭包中，
C++11 没有办法做这事。如果你有个对象的拷贝操作昂贵，但移动操作廉价（例如，大部分的标准容器），然后你需要把这个对象放入闭包中，
那么比起拷贝这个对象你更愿意移动它。但是，C++11 还是没有办法完成这事。
</p>
<p>
但那是 C++11，C++14 就不一样啦，它直接支持将对象移动到闭包。如果你的编译器支持 C++14，欢呼吧，然后继续读下去。如果你依然使用 C++11 的编译器，
你还是应该欢呼和继续读下去，因为 C++11 有接近移动捕获行为的办法。
</p>
<p>
缺少移动捕获被认为是 C++11 的一个缺陷，最直接的补救方法是在 C++14 中加上它，但标准委员会采用了另外一种方法。它们提出了一种新的、十分灵活的捕获技术，
引用捕获只是属于这种技术的其中一种把戏。这种新能力被称为初始化捕获（ <strong>init capture</strong> ），实际上，它可以做 C++11 捕获格式能做的所有事情，而且更多。
初始化捕获不能表示的是默认捕获模式，不过条款 31 解释过无论如何你都应该远离默认捕获模式。（对于将 C++11 捕获转换为初始化捕获的情况，
初始化捕获的语法会比较啰嗦，所以如果 C++11 捕获能解决问题的情况下，最好使用 C++11 捕获。）
</p>
<p>
使用初始化捕获让你有可能指定
</p>
<ol>
<li>
<p>
成员变量的名字（留意，这是闭包类的成员变量，这个闭包类由 lambda 生成）和
</p>
</li>
<li>
<p>
（初始化那成员变量的）表达式 。
</p>
</li>
</ol>
<p>
这里是如何使用初始化捕获来把 std::unique_ptr 移动到闭包内：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">Widget</span> { <span style="color:#75715e">// some useful type
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#960050;background-color:#1e0010">…</span>
	  <span style="color:#66d9ef">bool</span> isValidated() <span style="color:#66d9ef">const</span>;
	  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isProcessed</span>() <span style="color:#66d9ef">const</span>;
	  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isArchived</span>() <span style="color:#66d9ef">const</span>;
  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	  <span style="color:#960050;background-color:#1e0010">…</span>
  };
<span style="color:#66d9ef">auto</span> pw <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>(); <span style="color:#75715e">// create Widget; see
</span><span style="color:#75715e">// Item 21 for info on
</span><span style="color:#75715e">// std::make_unique
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// configure *pw
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> func <span style="color:#f92672">=</span> [pw <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(pw)] <span style="color:#75715e">// init data mbr
</span><span style="color:#75715e"></span>{ <span style="color:#66d9ef">return</span> pw<span style="color:#f92672">-&gt;</span>isValidated() <span style="color:#75715e">// in closure w/
</span><span style="color:#75715e"></span><span style="color:#f92672">&amp;&amp;</span> pw<span style="color:#f92672">-&gt;</span>isArchived(); }; <span style="color:#75715e">// std::move(pw)
</span></code></pre></div>
</div>
<p>
初始化捕获的代码部分是 <strong>pw = std::move(pw)</strong> ，“=”左边的是你指定的闭包类的成员变量名，右边的是进行初始化表达式。
<span style="text-decoration: underline;">有趣的是，“=”左边的作用域和右边的作用域不同，左边的作用域是在闭包类内，而右边的作用域和 lambda 被定义的地方的作用域相同</span> 。
在上面的例子中，“=”左边的名字 pw 指的是闭包类的成员变量，而右边的名字 pw 指的是在 lambda 之前声明的对象，即由 make_unique 创建的对象。
所以 pw = std::move(pw)的意思是：在闭包中创建一个成员变量 pw，然后用——对局部变量 pw 使用 std::move 的——结果初始化那个成员变量。
</p>
<p>
通常，lambda 体内代码的作用域在闭包类内，所以代码中的 pw 指的是闭包类的成员变量。
</p>
<p>
在上面例子中，注释“configure *pw””表明了在 std::make_unique 创建 Widget 之后，在 lambda 捕获指向 Widget 的 std::unique_ptr 之前，
Widget 在某些方面会被修改。如果这个配置不是必需的，即，如果 std::make_unique 创建的 Widget 对象的状态已经适合被 lambda 捕获，
那么局部变量 pw 是不必要的，因为闭包类的成员变量可以直接被 std::make_unique 初始化：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">auto</span> func <span style="color:#f92672">=</span> [pw <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>()] <span style="color:#75715e">// init data mbr
</span><span style="color:#75715e"></span>  { <span style="color:#66d9ef">return</span> pw<span style="color:#f92672">-&gt;</span>isValidated() <span style="color:#75715e">// in closure w/
</span><span style="color:#75715e"></span>	<span style="color:#f92672">&amp;&amp;</span> pw<span style="color:#f92672">-&gt;</span>isArchived(); }; <span style="color:#75715e">// result of call
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// to make_unique
</span></code></pre></div>
</div>
<p>
这应该清楚地表明在 C++14 中，C++11 的“捕获”概念得到显著推广，因为在 C++11，不可能捕获一个表达式的结果。因此，
初始化捕获的另一个名字是 <strong>generalized lambda capture</strong> （广义 lambda 捕获？）。
</p>
<p>
但如果你使用的编译器不支持 C++14 的初始化捕获，那该怎么办呢？在不支持引用捕获的语言中，你该怎样完成引用捕获呢？
</p>
<p>
你要记得，一个 lambda 表达式会生成一个类，而且会创建那个类的对象。lambda 做不了的事情，你自己手写的类可以做。例如，
就像上面展示的 C++14 的 lambda 代码，在 C++11 中可被写成这样：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">IsValAndArch</span> { <span style="color:#75715e">// &#34;is validated
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span> <span style="color:#75715e">// and archived&#34;
</span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">using</span> DataType <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>;
	  <span style="color:#66d9ef">explicit</span> <span style="color:#a6e22e">IsValAndArch</span>(DataType<span style="color:#f92672">&amp;&amp;</span> ptr) <span style="color:#75715e">// Item 25 explains
</span><span style="color:#75715e"></span>		  <span style="color:#f92672">:</span> pw(std<span style="color:#f92672">::</span>move(ptr)) {} <span style="color:#75715e">// use of std::move
</span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span>()() <span style="color:#66d9ef">const</span>
		  { <span style="color:#66d9ef">return</span> pw<span style="color:#f92672">-&gt;</span>isValidated() <span style="color:#f92672">&amp;&amp;</span> pw<span style="color:#f92672">-&gt;</span>isArchived(); }
  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	  DataType pw;
  };
  <span style="color:#66d9ef">auto</span> func <span style="color:#f92672">=</span> IsValAndArch(std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>());
</code></pre></div>
</div>
<p>
这比起写 lambda 多做了很多工作，事实上没有改变：在 C++11 中，如果你想要一个支持成员变量移动初始化的类，
那么你和你的需求之间相隔的唯一东西，就是花费一点时间在你的键盘上。
</p>
<p>
如果你想要坚持使用 lambda，C++11 可以模仿移动捕获，通过
</p>
<ol>
<li>
<p>
把需要捕获的对象移动到 std::bind 产生的函数中，
</p>
</li>
<li>
<p>
给 lambda 一个要“捕获”对象的引用（作为参数）。
</p>
</li>
</ol>
<p>
如果你熟悉 std::bind，代码是很直截了当的；如果你不熟悉 std::bind，代码会有一些需要习惯的、但值得的问题。
</p>
<p>
假如你创建了一个局部的 std::vector，把一系列合适的值放进去，然后想要把它移动到闭包中。在 C++14，这很容易：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> data; <span style="color:#75715e">// object to be moved
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// into closure
</span><span style="color:#75715e"></span>  <span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// populate data
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> func <span style="color:#f92672">=</span> [data <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(data)] <span style="color:#75715e">// C++14 init capture
</span><span style="color:#75715e"></span>  { <span style="color:#75715e">/* uses of data */</span> };
</code></pre></div>
</div>
<p>
这代码的关键部分是：你想要移动的对象的类型（std::vector&lt;double&gt;）和名字（data），还有初始化捕获中的初始化表达式（std::move(data)）。
C++11 的对等物也是一样：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> data; <span style="color:#75715e">// as above
</span><span style="color:#75715e"></span>  <span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// as above
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> func <span style="color:#f92672">=</span>
	  std<span style="color:#f92672">::</span>bind( <span style="color:#75715e">// C++11 emulation
</span><span style="color:#75715e"></span>		  [](<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;&amp;</span> data) <span style="color:#75715e">// of init capture
</span><span style="color:#75715e"></span>		  { <span style="color:#75715e">/* uses of data */</span> },
		  std<span style="color:#f92672">::</span>move(data)
		  );
</code></pre></div>
</div>
<p>
类似于 lambda 表达式，std::bind 产生一个函数对象。我把 std::bind 返回的函数对象称为 <strong>bind object</strong> （绑定对象）。
std::bind 的第一个参数是一个可执行对象，后面的参数代表传给可执行对象的值。
</p>
<p>
一个绑定对象含有传递给 std::bind 的所有实参的拷贝。对于每一个左值实参，在绑定对象内的对应的对象被拷贝构造，对于每一个右值实参，对应的对象被移动构造。
在这个例子中，第二个实参是右值（std::move 的结果——看条款 23），所以 data 在绑定对象中被移动构造。这个移动构造是移动捕获模仿物的关键，
因为把一个右值移动到绑定对象，我们就绕过 C++11 的无能——无法移动一个右值到 C++11 闭包。
</p>
<p>
当一个绑定对象被“调用”（即，它的函数调用操作符被调用），它存储的参数会传递给最开始的可执行对象（std::bind 的第一个参数）。
在这个例子中，那意味着当 func（绑定对象）被调用时，func 里的移动构造出的 data 拷贝作为参数传递给 lambda（即，一开始传递给 std::bind 的 lambda）。
</p>
<p>
这个 lambda 和 C++14 版本的 lambda 一样，除了形参，data，它相当于我们的虚假移动捕获对象。这个参数是一个——对绑定对象内的 data 拷贝的——左值引用。
（它不是一个右值引用，因为，即使初始化 data 拷贝的表达式是 std::move(data)，但 data 拷贝本身是一个左值。）因此，
在 lambda 里使用的 data，是在操作绑定对象内移动构造出的 data 的拷贝。
</p>
<p>
默认地， <span style="text-decoration: underline;">lambda 生成的闭包类里的 operator()成员函数是 const 的，这会导致闭包里的所有成员变量在 lambda 体内都是 const</span> 。但是，
绑定对象里移动构造出来的 data 拷贝不是 const 的，所以为了防止 data 拷贝在 lambda 内被修改，lambda 的形参声明为常量引用。
如果 lambda 被声明为 mutable，闭包里的 operator()函数就不会被声明为 const，所以此时在 lambda 声明中省略 const 比较合适
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">auto</span> func <span style="color:#f92672">=</span>
	  std<span style="color:#f92672">::</span>bind( <span style="color:#75715e">// C++11 emulation
</span><span style="color:#75715e"></span>		  [](std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;&amp;</span> data) <span style="color:#66d9ef">mutable</span> <span style="color:#75715e">// of init capture
</span><span style="color:#75715e"></span>		  { <span style="color:#75715e">/* uses of data */</span> }, <span style="color:#75715e">// for mutable lambda
</span><span style="color:#75715e"></span>		  std<span style="color:#f92672">::</span>move(data)
		  );
</code></pre></div>
</div>
<p>
因为一个绑定对象会存储传给 std::bind 的所有实参的拷贝，在我们的例子中，绑定对象持有一份由 lambda 产生的闭包的拷贝，它是 std::bind 的第一个实参。
因此闭包的生命期和绑定对象的生命期相同，那是很重要的，因为这意味着只要闭包存在，绑定对象内的虚假移动捕获对象也存在。
</p>
<p>
如果这是你第一次接触 std::bind，那么在深陷之前讨论的细节之前，你可能需要咨询你最喜欢的 C++11 参考书了。即使是这种情况，这些关键点你应该要清楚：
</p>
<ul>
<li>
<p>
在一个 C++11 闭包中移动构造一个对象是不可能的，但在绑定对象中移动构造一个对象是有可能的。
</p>
</li>
<li>
<p>
在 C++11 中模仿移动捕获需要在一个绑定对象内移动构造出一个对象，然后把该移动构造对象以引用传递给 lambda。
</p>
</li>
<li>
<p>
因为绑定对象的生命期和闭包的生命期相同，可以把绑定对象中的对象（即除可执行对象外的实参的拷贝）看作是闭包里的对象。
</p>
</li>
</ul>
<p>
作为使用 std::bind 模仿移动捕获的第二个例子，这里是我们之前看到的在 C++14，闭包内创建 std::unique_ptr 的代码：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">auto</span> func <span style="color:#f92672">=</span> [pw <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>()] <span style="color:#75715e">// as before,
</span><span style="color:#75715e"></span>  { <span style="color:#66d9ef">return</span> pw<span style="color:#f92672">-&gt;</span>isValidated() <span style="color:#75715e">// create pw
</span><span style="color:#75715e"></span>	<span style="color:#f92672">&amp;&amp;</span> pw<span style="color:#f92672">-&gt;</span>isArchived(); }; <span style="color:#75715e">// in closure
</span></code></pre></div>
</div>
<p>
这是 C++11 的模仿物：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">auto</span> func <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>bind(
	  [](<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;&amp;</span> pw)
	  { <span style="color:#66d9ef">return</span> pw<span style="color:#f92672">-&gt;</span>isValidated()
		<span style="color:#f92672">&amp;&amp;</span> pw<span style="color:#f92672">-&gt;</span>isArchived(); },
	  std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>()
	  );
</code></pre></div>
</div>
<p>
我展示了如何使用 std::bind 来绕开 C++11 的 lambda 的限制，这是很讽刺的，因为在条款 34 中，我提倡尽量使用 lambda 来代替 std::bind。
但是，那条款解释了，在 C++11 的某些情况 std::bind 是有用的，这里就是其中一个例子。（在 C++14，初始化捕获和 auto 形参这两个特性可以消除那些情况。）
</p>
<h2 id="headline-4">
记住
</h2>
<ul>
<li>
<p>
使用 C++14 的初始化捕获来把对象移到到闭包。
</p>
</li>
<li>
<p>
在 C++11，借助手写类或 std::bind 模仿初始化捕获。
</p>
</li>
</ul>
<h1 id="headline-5">
参考
</h1>
<p>
原文：effective-modern-c++
翻译：<a href="http://blog.csdn.net/big_yellow_duck/article/category/6352345">http://blog.csdn.net/big_yellow_duck/article/category/6352345</a>
</p>

                        </div>

                        


                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/c&#43;&#43;-ep13rvalue-referencesmove-semanticsand-perfect-forwarding5/">C&#43;&#43; Ep13:Rvalue References,Move Semantics,and Perfect Forwarding(5)</a></li>
        
        <li><a href="/post/c&#43;&#43;-ep12rvalue-referencesmove-semanticsand-perfect-forwarding4/">C&#43;&#43; Ep12:Rvalue References,Move Semantics,and Perfect Forwarding(4)</a></li>
        
        <li><a href="/post/c&#43;&#43;-ep11rvalue-referencesmove-semanticsand-perfect-forwarding3/">C&#43;&#43; Ep11:Rvalue References,Move Semantics,and Perfect Forwarding(3)</a></li>
        
        <li><a href="/post/c&#43;&#43;-ep10rvalue-referencesmove-semanticsand-perfect-forwarding2/">C&#43;&#43; Ep10:Rvalue References,Move Semantics,and Perfect Forwarding(2)</a></li>
        
        <li><a href="/post/c&#43;&#43;-ep08smart-pointers3/">C&#43;&#43; Ep08:Smart Pointers(3)</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="https://hardy5012.github.io/tags/c&#43;&#43;">C&#43;&#43;</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://hardy5012.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://hardy5012.github.io/post/%E4%B8%BA%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/" title="为运行的容器挂载文件目录">为运行的容器挂载文件目录</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/super%E6%B2%A1%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95/" title="super 没那么简单">super 没那么简单</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/postgres%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D%E5%88%86%E9%A1%B5%E6%96%B9%E5%BC%8F/" title="Postgres 中的五种分页方式">Postgres 中的五种分页方式</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/c&#43;&#43;-ep23-if-constexpt/" title="C&#43;&#43; Ep23: constexpr if">C&#43;&#43; Ep23: constexpr if</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/c&#43;&#43;-ep22-fibonacci/" title="C&#43;&#43; Ep22: Fibonacci">C&#43;&#43; Ep22: Fibonacci</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/c&#43;&#43;-ep21-variadic-templates/" title="C&#43;&#43; Ep21: variadic Templates">C&#43;&#43; Ep21: variadic Templates</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/c&#43;&#43;-ep20-static-variable/" title="C&#43;&#43; Ep20: Static Variable">C&#43;&#43; Ep20: Static Variable</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/tweaks2/" title="Tweaks(2)">Tweaks(2)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/tweaks1/" title="Tweaks(1)">Tweaks(1)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/c&#43;&#43;-ep19the-concurrency-api4/" title="C&#43;&#43; Ep19:The Concurrency API(4)">C&#43;&#43; Ep19:The Concurrency API(4)</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://hardy5012.github.io/categories/ai/">ai(5)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/categories/c&#43;&#43;/">c&#43;&#43;(20)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/categories/date/">date(1)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/categories/modern/">modern(16)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/categories/notes/">notes(10)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/categories/summary/">summary(5)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/categories/weekly/">weekly(4)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://hardy5012.github.io/tags/boost/">boost</a>
    
    <a href="https://hardy5012.github.io/tags/c&#43;&#43;/">c&#43;&#43;</a>
    
    <a href="https://hardy5012.github.io/tags/constexpr/">constexpr</a>
    
    <a href="https://hardy5012.github.io/tags/docker/">docker</a>
    
    <a href="https://hardy5012.github.io/tags/etf/">etf</a>
    
    <a href="https://hardy5012.github.io/tags/fibonacci/">fibonacci</a>
    
    <a href="https://hardy5012.github.io/tags/git/">git</a>
    
    <a href="https://hardy5012.github.io/tags/gprof/">gprof</a>
    
    <a href="https://hardy5012.github.io/tags/heroku/">heroku</a>
    
    <a href="https://hardy5012.github.io/tags/linear/">linear</a>
    
    <a href="https://hardy5012.github.io/tags/linux/">linux</a>
    
    <a href="https://hardy5012.github.io/tags/logistic/">logistic</a>
    
    <a href="https://hardy5012.github.io/tags/makefile/">makefile</a>
    
    <a href="https://hardy5012.github.io/tags/neural/">neural</a>
    
    <a href="https://hardy5012.github.io/tags/postgrespaginate/">postgrespaginate</a>
    
    <a href="https://hardy5012.github.io/tags/protobuf/">protobuf</a>
    
    <a href="https://hardy5012.github.io/tags/python/">python</a>
    
    <a href="https://hardy5012.github.io/tags/regression/">regression</a>
    
    <a href="https://hardy5012.github.io/tags/regularization/">regularization</a>
    
    <a href="https://hardy5012.github.io/tags/spacemacs/">spacemacs</a>
    
    <a href="https://hardy5012.github.io/tags/static/">static</a>
    
    <a href="https://hardy5012.github.io/tags/template/">template</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://hardy5012.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="https://hardy5012.github.io/">Learning Hardy By </a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>






</body>
</html>
