<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; Ep14:Lambda Epressions(1) - Leaning Hardy</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Hardy Li" /><meta name="description" content="Item31:对于 lambda 表达式，避免使用默认捕获模式 C&#43;&#43;11 中有两种默认捕获模式：引用捕获或值捕获。默认的引用捕获模式可能会导致悬挂引用，默认的值捕获" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.57.0 with even 4.0.0" />


<link rel="canonical" href="https://hardy5012.github.io/post/c&#43;&#43;-ep14lambda-epressions1/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43; Ep14:Lambda Epressions(1)" />
<meta property="og:description" content="Item31:对于 lambda 表达式，避免使用默认捕获模式 C&#43;&#43;11 中有两种默认捕获模式：引用捕获或值捕获。默认的引用捕获模式可能会导致悬挂引用，默认的值捕获" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hardy5012.github.io/post/c&#43;&#43;-ep14lambda-epressions1/" />
<meta property="article:published_time" content="2018-01-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-01-11T00:00:00+00:00" />
<meta itemprop="name" content="C&#43;&#43; Ep14:Lambda Epressions(1)">
<meta itemprop="description" content="Item31:对于 lambda 表达式，避免使用默认捕获模式 C&#43;&#43;11 中有两种默认捕获模式：引用捕获或值捕获。默认的引用捕获模式可能会导致悬挂引用，默认的值捕获">


<meta itemprop="datePublished" content="2018-01-11T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2018-01-11T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="6790">



<meta itemprop="keywords" content="C&#43;&#43;," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; Ep14:Lambda Epressions(1)"/>
<meta name="twitter:description" content="Item31:对于 lambda 表达式，避免使用默认捕获模式 C&#43;&#43;11 中有两种默认捕获模式：引用捕获或值捕获。默认的引用捕获模式可能会导致悬挂引用，默认的值捕获"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Learning</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Learning</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; Ep14:Lambda Epressions(1)</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-01-11 </span>
        <div class="post-category">
            <a href="/categories/modern/"> Modern </a>
            <a href="/categories/c&#43;&#43;/"> C&#43;&#43; </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#headline-1">Item31:对于 lambda 表达式，避免使用默认捕获模式</a>
<ul>
<li><a href="#headline-2">记住</a>
</li>
</ul>
</li>
<li><a href="#headline-3">Item 32:使用初始化捕获来把对象移动到闭包</a>
<ul>
<li><a href="#headline-4">记住</a>
</li>
</ul>
</li>
<li><a href="#headline-5">参考</a>
</li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      
<h1 id="headline-1">
Item31:对于 lambda 表达式，避免使用默认捕获模式
</h1>
<p>
C++11 中有两种默认捕获模式：引用捕获或值捕获。默认的引用捕获模式可能会导致悬挂引用，默认的值捕获模式诱骗你——让你认为你可以免疫刚说的问题（事实上没有免疫），
然后它又骗你——让你认为你的闭包是独立的（事实上它们可能不是独立的）
</p>
<!-- more -->
<p>
那就是本条款的总纲。如果你是工程师，你会想要更具体的内容，所以让我们从默认捕获模式的危害开始说起吧。
</p>
<p>
引用捕获会导致闭包包含一个局部变量的引用或者一个形参的引用（在定义 lamda 的作用域）。如果一个由 lambda 创建的闭包的生命期超过了局部变量或者形参的生命期，
那么闭包的引用将会空悬。例如，我们有一个容器，它的元素是过滤函数，这种过滤函数接受一个 int，返回 bool 表示传入的值是否可以满足过滤条件：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">using</span> <span class="n">FilterContainer</span> <span class="o">=</span> <span class="c1">// see Item 9 for
</span><span class="c1"></span>	  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">;</span> <span class="c1">// &#34;using&#34;, Item 2
</span><span class="c1"></span>  <span class="c1">// for std::function
</span><span class="c1"></span>  <span class="n">FilterContainer</span> <span class="n">filters</span><span class="p">;</span> <span class="c1">// filtering funcs
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
我们可以通过添加一个过滤器，过滤掉 5 的倍数，像这样：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="c1">// see Item 42 for
</span><span class="c1"></span>	  <span class="p">[](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// info on
</span><span class="c1"></span>	  <span class="p">);</span> <span class="c1">// emplace_back
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
但是，我们可能需要在运行期间计算被除数，而不是直接把硬编码 5 写到 lambda 中，所以添加过滤器的代码可能是这样的：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="nf">addDivisorFilter</span><span class="p">()</span>
  <span class="p">{</span>
	  <span class="k">auto</span> <span class="n">calc1</span> <span class="o">=</span> <span class="n">computeSomeValue1</span><span class="p">();</span>
	  <span class="k">auto</span> <span class="n">calc2</span> <span class="o">=</span> <span class="n">computeSomeValue2</span><span class="p">();</span>
	  <span class="k">auto</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">computeDivisor</span><span class="p">(</span><span class="n">calc1</span><span class="p">,</span> <span class="n">calc2</span><span class="p">);</span>
	  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="c1">// danger!
</span><span class="c1"></span>		  <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// ref to
</span><span class="c1"></span>		  <span class="p">);</span> <span class="c1">// divisor
</span><span class="c1"></span>  <span class="p">}</span> <span class="c1">// will
</span><span class="c1"></span>  <span class="c1">// dangle!
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这代码有个定时炸弹。lambda 引用了局部变量 divisor， 但是局部变量的生命期在 addDivisorFilter 返回时终止，也就是在 filters.emplace_back 返回之后，
所以添加到容器的函数本质上就像是一到达容器就死亡了。使用那个过滤器会产生未定义行为，这实际上是在创建过滤器的时候就决定好的了。
</p>
<p>
现在呢，如果显式引用捕获 divisor，会存在着同样的问题：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
	  <span class="p">[</span><span class="o">&amp;</span><span class="n">divisor</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// danger! ref to
</span><span class="c1"></span>	  <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// divisor will
</span><span class="c1"></span>	  <span class="p">);</span> <span class="c1">// still dangle!
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
不过使用显示捕获，很容易就可以看出 lambda 的活性依赖于 divisor 的生命期。而且，写出名字“divisor”会提醒我们，
要确保 divisor 的生命期至少和 lambda 闭包一样长。比起用“[&amp;]”表达“确保不会空悬”，显式捕获更容易让你想起这个告诫。
</p>
<p>
如果你知道一个闭包创建后马上被使用（例如，传递给 STL 算法）而且不会被拷贝，那么引用的局部变量或参数就没有风险。
在这种情况下，你可能会争论，没有空悬引用的风险，因此没有理由避免使用默认的引用捕获模式，
例如，我们的过滤 lambda 只是作为 C++11 的 std::all_of 的参数（std::all_of 返回范围内元素是否都满足某个条件）：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">workWithContainer</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">)</span>
  <span class="p">{</span>
	  <span class="k">auto</span> <span class="n">calc1</span> <span class="o">=</span> <span class="n">computeSomeValue1</span><span class="p">();</span> <span class="c1">// as above
</span><span class="c1"></span>	  <span class="k">auto</span> <span class="n">calc2</span> <span class="o">=</span> <span class="n">computeSomeValue2</span><span class="p">();</span> <span class="c1">// as above
</span><span class="c1"></span>	  <span class="k">auto</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">computeDivisor</span><span class="p">(</span><span class="n">calc1</span><span class="p">,</span> <span class="n">calc2</span><span class="p">);</span> <span class="c1">// as above
</span><span class="c1"></span>	  <span class="k">using</span> <span class="n">ContElemT</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span> <span class="c1">// type of
</span><span class="c1"></span>  <span class="c1">// elements in
</span><span class="c1"></span>  <span class="c1">// container
</span><span class="c1"></span>	  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">;</span> <span class="c1">// for
</span><span class="c1"></span>	  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">;</span> <span class="c1">// genericity;
</span><span class="c1"></span>  <span class="c1">// see Item 13
</span><span class="c1"></span>	  <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span> <span class="c1">// if all values
</span><span class="c1"></span>			  <span class="n">begin</span><span class="p">(</span><span class="n">container</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">container</span><span class="p">),</span> <span class="c1">// in container
</span><span class="c1"></span>			  <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">ContElemT</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// are multiples
</span><span class="c1"></span>			  <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">})</span> <span class="c1">// of divisor...
</span><span class="c1"></span>		  <span class="p">)</span> <span class="p">{</span>
		  <span class="err">…</span> <span class="c1">// they are...
</span><span class="c1"></span>			  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		  <span class="err">…</span> <span class="c1">// at least one
</span><span class="c1"></span>			  <span class="p">}</span> <span class="c1">// isn&#39;t...
</span><span class="c1"></span>  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
当然，这是安全的，但是它的安全有点不稳定，如果发现 lambda 在其他上下文很有用（例如，作为函数加入到过滤器容器），然后拷贝及粘贴到其他上下文，
在那里 divisor 已经死亡，而闭包还健全，你又回到了空悬的境地，同时，在捕获语句中，也没有特别提醒你对 divisor 进行生命期分析（即没有显式捕获）。
</p>
<p>
从长期来看，显式列出 lambda 依赖的局部变量或形参是更好的软件工程。
</p>
<p>
顺便说下，C++14 的 lambda 形参可以使用 auto 声明，意味着上面的代码可以用 C++14 简化，ContElemT 的那个 typedef 可以删去，
然后把 if 语句的条件改成这样：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">container</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">container</span><span class="p">),</span>
				  <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// C++14
</span><span class="c1"></span>				  <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}))</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
解决这个问题的一种办法是对 divisor 使用默认的值捕获模式。即，我们这样向容器添加 lambda：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="c1">// now
</span><span class="c1"></span>	  <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// divisor
</span><span class="c1"></span>	  <span class="p">);</span> <span class="c1">// can&#39;t
</span><span class="c1"></span>  <span class="c1">// dangle
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这满足这个例子的需要，但是，总的来说，默认以值捕获不是对抗空悬的长生不老药。问题在于，如果你用值捕获了个指针，
你在 lambda 创建的闭包中持有这个指针的拷贝，但你不能阻止 lambda 外面的代码删除指针指向的内容，从而导致你拷贝的指针空悬。
</p>
<p>
“这不可能发生”你在抗议，“自从看了第四章，我十分热爱智能指针。只有智障的 C++98 程序员才会使用原生指针和 delete。
”你说的可能是正确的，但这是不相关的，因为实际上你真的会使用原生指针，而它们实际上也会在你眼皮底下被删除，只不过在你的现代 C++编程风格中，
它们（原生指针）在源代码中不露迹象。。
</p>
<p>
假如 Widget 类可以做的其中一件事是，向过滤器容器添加条目：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span><span class="err"> </span><span class="nc">Widget</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
	  <span class="err">…</span> <span class="c1">// ctors, etc.
</span><span class="c1"></span>	  <span class="kt">void</span> <span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// add an entry to filters
</span><span class="c1"></span>  <span class="k">private</span><span class="o">:</span>
	  <span class="kt">int</span> <span class="n">divisor</span><span class="p">;</span> <span class="c1">// used in Widget&#39;s filter
</span><span class="c1"></span>  <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
Widget::addFilter 可能定义成这样：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
	  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
		  <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
		  <span class="p">);</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
对于外行人，这看起来像是安全的代码。lambda 依赖 divisor，但默认的以值捕获模式确保了 divisor 被拷贝到 lambda 创建的闭包里，对吗？
</p>
<p>
错了，完全错了。
</p>
<p>
<span style="text-decoration: underline;">捕获只能用于可见（在创建 lambda 的作用域可见）的非 static 局部变量（包含形参）</span> 。在 Widget::addFilter 内部，
divisor 不是局部变量，它是 Widget 类的成员变量，它是不能被捕获的，如果默认捕获模式被删除，代码就不能编译了：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
	  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="c1">// error!
</span><span class="c1"></span>		  <span class="p">[](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// divisor
</span><span class="c1"></span>		  <span class="p">);</span> <span class="c1">// not
</span><span class="c1"></span>  <span class="p">}</span> <span class="c1">// available
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
而且，如果试图显式捕获 divisor（无论是值捕获还是引用捕获，这都没有关系），捕获不会通过编译，因为 divisor 不是局部变量或形参：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
	  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
		  <span class="p">[</span><span class="n">divisor</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// error! no local
</span><span class="c1"></span>		  <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// divisor to capture
</span><span class="c1"></span>		  <span class="p">);</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
所以如果在默认值捕获语句中（即“[=]”），捕获的不是 divisor，而不是默认值捕获语句就不能编译，那么前者发生了什么？
</p>
<p>
问题解释取决于原生指针的隐式使用： <strong>this</strong> 。每一个非 static 成员函数都有一个 this 指针，然后每当你使用类的成员变量时都用到这个指针。
例如，在 Widget 的一些成员函数中，编译器内部会把 divisor 替换成 this-&gt;divisor。在 Widget::addFiliter 的默认值捕获版本中，
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
	  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
		  <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
		  <span class="p">);</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
被捕获的是 Widget 的 this 指针，而不是 divisor，编译器把上面的代码视为这样写的：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
	  <span class="k">auto</span> <span class="n">currentObjectPtr</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
	  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
		  <span class="p">[</span><span class="n">currentObjectPtr</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
		  <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">currentObjectPtr</span><span class="o">-&gt;</span><span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
		  <span class="p">);</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
理解了这个就相当于理解了 lambda 闭包的活性与 Widget 对象的生命期有紧密关系，闭包内含有 Widget 的 this 指针的拷贝。
特别是，思考下面的代码，它根据第 4 章，只是用智能指针：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">using</span> <span class="n">FilterContainer</span> <span class="o">=</span> <span class="c1">// as before
</span><span class="c1"></span>	  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">;</span>
  <span class="n">FilterContainer</span> <span class="n">filters</span><span class="p">;</span> <span class="c1">// as before
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">doSomeWork</span><span class="p">()</span>
  <span class="p">{</span>
	  <span class="k">auto</span> <span class="n">pw</span> <span class="o">=</span> <span class="c1">// create Widget; see
</span><span class="c1"></span>		  <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// Item 21 for
</span><span class="c1"></span>  <span class="c1">// std::make_unique
</span><span class="c1"></span>	  <span class="n">pw</span><span class="o">-&gt;</span><span class="n">addFilter</span><span class="p">();</span> <span class="c1">// add filter that uses
</span><span class="c1"></span>  <span class="c1">// Widget::divisor
</span><span class="c1"></span>	  <span class="err">…</span>
		  <span class="p">}</span> <span class="c1">// destroy Widget; filters
</span><span class="c1"></span>  <span class="c1">// now holds dangling pointer!
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
当调用 doSomeWork 时，创建了一个过滤函数，它依赖 std::make_unique 创建的 Widget 对象，即，那个过滤函数内含有指向 Widget 指针——即，
Widget 的 this 指针——的拷贝。这个函数被添加到 filters 中，不过当 doSomeWork 执行结束之后，Widget 对象被销毁，
因为它的生命期由 std::unique_ptr 管理（看条款 18）。从那一刻起，filters 中含有一个带空悬指针的条目。
</p>
<p>
通过将你想捕获的成员变量拷贝到局部变量中，然后捕获这个局部拷贝，就可以解决这个特殊的问题了：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
	  <span class="k">auto</span> <span class="n">divisorCopy</span> <span class="o">=</span> <span class="n">divisor</span><span class="p">;</span> <span class="c1">// copy data member
</span><span class="c1"></span>	  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
		  <span class="p">[</span><span class="n">divisorCopy</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// capture the copy
</span><span class="c1"></span>		  <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisorCopy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// use the copy
</span><span class="c1"></span>		  <span class="p">);</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
实话说，如果你用这种方法，那么默认值捕获也是可以工作的
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
	  <span class="k">auto</span> <span class="n">divisorCopy</span> <span class="o">=</span> <span class="n">divisor</span><span class="p">;</span> <span class="c1">// copy data member
</span><span class="c1"></span>	  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
		  <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// capture the copy
</span><span class="c1"></span>		  <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisorCopy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// use the copy
</span><span class="c1"></span>		  <span class="p">);</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
但是，我们为什么要冒险呢？在一开始的代码，默认值捕获就意外地捕获了 this 指针，而不是你以为的 divisor。
</p>
<p>
在 C++14 中，捕获成员变量一种更好的方法是使用广义 lambda 捕获（ <strong>generalized lambda capture</strong> ，即，捕获语句可以是表达式，看条款 32）：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
	  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="c1">// C++14:
</span><span class="c1"></span>		  <span class="p">[</span><span class="n">divisor</span> <span class="o">=</span> <span class="n">divisor</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// copy divisor to closure
</span><span class="c1"></span>		  <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// use the copy
</span><span class="c1"></span>		  <span class="p">);</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
广义 lambda 捕获没有默认捕获模式，但是，就算在 C++14，本条款的建议——避免使用默认捕获模式——依然成立。
</p>
<p>
使用默认值捕获模式的一个另外的缺点是：它们表明闭包是独立的，不受闭包外数据变化的影响。总的来说，这是不真实的，
因为 lambda 可能不会依赖于局部变量和形参，但它们会依赖于静态存储周期的对象（ <strong>static storage duration</strong> ）。
这样的对象定义在全局作用域或者命名空间作用域，又或者在类中、函数中、文件中声明为 static。这样的对象可以在 lambda 内使用，
但是它们不能被捕获。如果你使用了默认值捕获模式，这些对象会给你错觉，让你认为它们可以捕获。思考下面这个修改版本的 addDivisorFilter 函数：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="nf">addDivisorFilter</span><span class="p">()</span>
  <span class="p">{</span>
	  <span class="k">static</span> <span class="k">auto</span> <span class="n">calc1</span> <span class="o">=</span> <span class="n">computeSomeValue1</span><span class="p">();</span> <span class="c1">// now static
</span><span class="c1"></span>	  <span class="k">static</span> <span class="k">auto</span> <span class="n">calc2</span> <span class="o">=</span> <span class="n">computeSomeValue2</span><span class="p">();</span> <span class="c1">// now static
</span><span class="c1"></span>	  <span class="k">static</span> <span class="k">auto</span> <span class="n">divisor</span> <span class="o">=</span> <span class="c1">// now static
</span><span class="c1"></span>		  <span class="n">computeDivisor</span><span class="p">(</span><span class="n">calc1</span><span class="p">,</span> <span class="n">calc2</span><span class="p">);</span>
	  <span class="n">filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
		  <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// captures nothing!
</span><span class="c1"></span>		  <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// refers to above static
</span><span class="c1"></span>		  <span class="p">);</span>
	  <span class="o">++</span><span class="n">divisor</span><span class="p">;</span> <span class="c1">// modify divisor
</span><span class="c1"></span>  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这份代码，对于随便的读者，他们看到“[=]”然后想，“很好，lambda 拷贝了它内部使用的对象，因此 lambda 是独立的。”，这可以被谅解。
但这 lambda 不是独立的，它没有使用任何的非 static 局部变量和形参，所以它没有捕获任何东西。
更糟的是，lambda 的代码引用了 static 变量 divisor。在每次调用 addDivisorFilter 的最后，divisor 都会被递增，
通过这个函数，会把好多个 lambda 添加到 filiters，每一个 lambda 的行为都是新的（对应新的 divisor 值）。
从实践上讲，这个 lambda 是通过 <span style="text-decoration: underline;">引用捕获 divisor</span> (所以 filiters 中的所有 lambda 都将用的最终的 divisor 进行计算) ，和默认值捕获语句表示的含义有直接的矛盾。
如果你一开始就远离默认的值捕获模式，你就能消除理解错代码的风险。
</p>
<h2 id="headline-2">
记住
</h2>
<ul>
<li>
<p>
默认引用捕获会导致空悬引用。
</p>
</li>
<li>
<p>
默认值捕获对空悬指针（尤其是 this）很敏感，而且它会误导地表明 lambda 是独立
</p>
</li>
</ul>
<h1 id="headline-3">
Item 32:使用初始化捕获来把对象移动到闭包
</h1>
<p>
有时候，你想要的既不是值捕获，也不是引用捕获。如果你想要把一个只可移动对象（例如，std::unique_ptr 或 std::future 类型对象）放入闭包中，
C++11 没有办法做这事。如果你有个对象的拷贝操作昂贵，但移动操作廉价（例如，大部分的标准容器），然后你需要把这个对象放入闭包中，
那么比起拷贝这个对象你更愿意移动它。但是，C++11 还是没有办法完成这事。
</p>
<p>
但那是 C++11，C++14 就不一样啦，它直接支持将对象移动到闭包。如果你的编译器支持 C++14，欢呼吧，然后继续读下去。如果你依然使用 C++11 的编译器，
你还是应该欢呼和继续读下去，因为 C++11 有接近移动捕获行为的办法。
</p>
<p>
缺少移动捕获被认为是 C++11 的一个缺陷，最直接的补救方法是在 C++14 中加上它，但标准委员会采用了另外一种方法。它们提出了一种新的、十分灵活的捕获技术，
引用捕获只是属于这种技术的其中一种把戏。这种新能力被称为初始化捕获（ <strong>init capture</strong> ），实际上，它可以做 C++11 捕获格式能做的所有事情，而且更多。
初始化捕获不能表示的是默认捕获模式，不过条款 31 解释过无论如何你都应该远离默认捕获模式。（对于将 C++11 捕获转换为初始化捕获的情况，
初始化捕获的语法会比较啰嗦，所以如果 C++11 捕获能解决问题的情况下，最好使用 C++11 捕获。）
</p>
<p>
使用初始化捕获让你有可能指定
</p>
<ol>
<li>
<p>
成员变量的名字（留意，这是闭包类的成员变量，这个闭包类由 lambda 生成）和
</p>
</li>
<li>
<p>
（初始化那成员变量的）表达式 。
</p>
</li>
</ol>
<p>
这里是如何使用初始化捕获来把 std::unique_ptr 移动到闭包内：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span><span class="err"> </span><span class="nc">Widget</span> <span class="p">{</span> <span class="c1">// some useful type
</span><span class="c1"></span>  <span class="k">public</span><span class="o">:</span>
	  <span class="err">…</span>
	  <span class="kt">bool</span> <span class="n">isValidated</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
	  <span class="kt">bool</span> <span class="nf">isProcessed</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
	  <span class="kt">bool</span> <span class="nf">isArchived</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">private</span><span class="o">:</span>
	  <span class="err">…</span>
  <span class="p">};</span>
<span class="k">auto</span> <span class="n">pw</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// create Widget; see
</span><span class="c1">// Item 21 for info on
</span><span class="c1">// std::make_unique
</span><span class="c1"></span><span class="err">…</span> <span class="c1">// configure *pw
</span><span class="c1"></span><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">pw</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pw</span><span class="p">)]</span> <span class="c1">// init data mbr
</span><span class="c1"></span><span class="p">{</span> <span class="k">return</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isValidated</span><span class="p">()</span> <span class="c1">// in closure w/
</span><span class="c1"></span><span class="o">&amp;&amp;</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isArchived</span><span class="p">();</span> <span class="p">};</span> <span class="c1">// std::move(pw)
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
初始化捕获的代码部分是 <strong>pw = std::move(pw)</strong> ，“=”左边的是你指定的闭包类的成员变量名，右边的是进行初始化表达式。
<span style="text-decoration: underline;">有趣的是，“=”左边的作用域和右边的作用域不同，左边的作用域是在闭包类内，而右边的作用域和 lambda 被定义的地方的作用域相同</span> 。
在上面的例子中，“=”左边的名字 pw 指的是闭包类的成员变量，而右边的名字 pw 指的是在 lambda 之前声明的对象，即由 make_unique 创建的对象。
所以 pw = std::move(pw)的意思是：在闭包中创建一个成员变量 pw，然后用——对局部变量 pw 使用 std::move 的——结果初始化那个成员变量。
</p>
<p>
通常，lambda 体内代码的作用域在闭包类内，所以代码中的 pw 指的是闭包类的成员变量。
</p>
<p>
在上面例子中，注释“configure *pw””表明了在 std::make_unique 创建 Widget 之后，在 lambda 捕获指向 Widget 的 std::unique_ptr 之前，
Widget 在某些方面会被修改。如果这个配置不是必需的，即，如果 std::make_unique 创建的 Widget 对象的状态已经适合被 lambda 捕获，
那么局部变量 pw 是不必要的，因为闭包类的成员变量可以直接被 std::make_unique 初始化：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">pw</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">()]</span> <span class="c1">// init data mbr
</span><span class="c1"></span>  <span class="p">{</span> <span class="k">return</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isValidated</span><span class="p">()</span> <span class="c1">// in closure w/
</span><span class="c1"></span>	<span class="o">&amp;&amp;</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isArchived</span><span class="p">();</span> <span class="p">};</span> <span class="c1">// result of call
</span><span class="c1"></span>  <span class="c1">// to make_unique
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这应该清楚地表明在 C++14 中，C++11 的“捕获”概念得到显著推广，因为在 C++11，不可能捕获一个表达式的结果。因此，
初始化捕获的另一个名字是 <strong>generalized lambda capture</strong> （广义 lambda 捕获？）。
</p>
<p>
但如果你使用的编译器不支持 C++14 的初始化捕获，那该怎么办呢？在不支持引用捕获的语言中，你该怎样完成引用捕获呢？
</p>
<p>
你要记得，一个 lambda 表达式会生成一个类，而且会创建那个类的对象。lambda 做不了的事情，你自己手写的类可以做。例如，
就像上面展示的 C++14 的 lambda 代码，在 C++11 中可被写成这样：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span><span class="err"> </span><span class="nc">IsValAndArch</span> <span class="p">{</span> <span class="c1">// &#34;is validated
</span><span class="c1"></span>  <span class="k">public</span><span class="o">:</span> <span class="c1">// and archived&#34;
</span><span class="c1"></span>	  <span class="k">using</span> <span class="n">DataType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">;</span>
	  <span class="k">explicit</span> <span class="nf">IsValAndArch</span><span class="p">(</span><span class="n">DataType</span><span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="p">)</span> <span class="c1">// Item 25 explains
</span><span class="c1"></span>		  <span class="o">:</span> <span class="n">pw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span> <span class="p">{}</span> <span class="c1">// use of std::move
</span><span class="c1"></span>	  <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()()</span> <span class="k">const</span>
		  <span class="p">{</span> <span class="k">return</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isValidated</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isArchived</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">private</span><span class="o">:</span>
	  <span class="n">DataType</span> <span class="n">pw</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="n">IsValAndArch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">());</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这比起写 lambda 多做了很多工作，事实上没有改变：在 C++11 中，如果你想要一个支持成员变量移动初始化的类，
那么你和你的需求之间相隔的唯一东西，就是花费一点时间在你的键盘上。
</p>
<p>
如果你想要坚持使用 lambda，C++11 可以模仿移动捕获，通过
</p>
<ol>
<li>
<p>
把需要捕获的对象移动到 std::bind 产生的函数中，
</p>
</li>
<li>
<p>
给 lambda 一个要“捕获”对象的引用（作为参数）。
</p>
</li>
</ol>
<p>
如果你熟悉 std::bind，代码是很直截了当的；如果你不熟悉 std::bind，代码会有一些需要习惯的、但值得的问题。
</p>
<p>
假如你创建了一个局部的 std::vector，把一系列合适的值放进去，然后想要把它移动到闭包中。在 C++14，这很容易：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// object to be moved
</span><span class="c1"></span>  <span class="c1">// into closure
</span><span class="c1"></span>  <span class="err">…</span> <span class="c1">// populate data
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span> <span class="c1">// C++14 init capture
</span><span class="c1"></span>  <span class="p">{</span> <span class="cm">/* uses of data */</span> <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这代码的关键部分是：你想要移动的对象的类型（std::vector&lt;double&gt;）和名字（data），还有初始化捕获中的初始化表达式（std::move(data)）。
C++11 的对等物也是一样：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// as above
</span><span class="c1"></span>  <span class="err">…</span> <span class="c1">// as above
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">func</span> <span class="o">=</span>
	  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="c1">// C++11 emulation
</span><span class="c1"></span>		  <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="c1">// of init capture
</span><span class="c1"></span>		  <span class="p">{</span> <span class="cm">/* uses of data */</span> <span class="p">},</span>
		  <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
		  <span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
类似于 lambda 表达式，std::bind 产生一个函数对象。我把 std::bind 返回的函数对象称为 <strong>bind object</strong> （绑定对象）。
std::bind 的第一个参数是一个可执行对象，后面的参数代表传给可执行对象的值。
</p>
<p>
一个绑定对象含有传递给 std::bind 的所有实参的拷贝。对于每一个左值实参，在绑定对象内的对应的对象被拷贝构造，对于每一个右值实参，对应的对象被移动构造。
在这个例子中，第二个实参是右值（std::move 的结果——看条款 23），所以 data 在绑定对象中被移动构造。这个移动构造是移动捕获模仿物的关键，
因为把一个右值移动到绑定对象，我们就绕过 C++11 的无能——无法移动一个右值到 C++11 闭包。
</p>
<p>
当一个绑定对象被“调用”（即，它的函数调用操作符被调用），它存储的参数会传递给最开始的可执行对象（std::bind 的第一个参数）。
在这个例子中，那意味着当 func（绑定对象）被调用时，func 里的移动构造出的 data 拷贝作为参数传递给 lambda（即，一开始传递给 std::bind 的 lambda）。
</p>
<p>
这个 lambda 和 C++14 版本的 lambda 一样，除了形参，data，它相当于我们的虚假移动捕获对象。这个参数是一个——对绑定对象内的 data 拷贝的——左值引用。
（它不是一个右值引用，因为，即使初始化 data 拷贝的表达式是 std::move(data)，但 data 拷贝本身是一个左值。）因此，
在 lambda 里使用的 data，是在操作绑定对象内移动构造出的 data 的拷贝。
</p>
<p>
默认地， <span style="text-decoration: underline;">lambda 生成的闭包类里的 operator()成员函数是 const 的，这会导致闭包里的所有成员变量在 lambda 体内都是 const</span> 。但是，
绑定对象里移动构造出来的 data 拷贝不是 const 的，所以为了防止 data 拷贝在 lambda 内被修改，lambda 的形参声明为常量引用。
如果 lambda 被声明为 mutable，闭包里的 operator()函数就不会被声明为 const，所以此时在 lambda 声明中省略 const 比较合适
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">func</span> <span class="o">=</span>
	  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span> <span class="c1">// C++11 emulation
</span><span class="c1"></span>		  <span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="k">mutable</span> <span class="c1">// of init capture
</span><span class="c1"></span>		  <span class="p">{</span> <span class="cm">/* uses of data */</span> <span class="p">},</span> <span class="c1">// for mutable lambda
</span><span class="c1"></span>		  <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
		  <span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
因为一个绑定对象会存储传给 std::bind 的所有实参的拷贝，在我们的例子中，绑定对象持有一份由 lambda 产生的闭包的拷贝，它是 std::bind 的第一个实参。
因此闭包的生命期和绑定对象的生命期相同，那是很重要的，因为这意味着只要闭包存在，绑定对象内的虚假移动捕获对象也存在。
</p>
<p>
如果这是你第一次接触 std::bind，那么在深陷之前讨论的细节之前，你可能需要咨询你最喜欢的 C++11 参考书了。即使是这种情况，这些关键点你应该要清楚：
</p>
<ul>
<li>
<p>
在一个 C++11 闭包中移动构造一个对象是不可能的，但在绑定对象中移动构造一个对象是有可能的。
</p>
</li>
<li>
<p>
在 C++11 中模仿移动捕获需要在一个绑定对象内移动构造出一个对象，然后把该移动构造对象以引用传递给 lambda。
</p>
</li>
<li>
<p>
因为绑定对象的生命期和闭包的生命期相同，可以把绑定对象中的对象（即除可执行对象外的实参的拷贝）看作是闭包里的对象。
</p>
</li>
</ul>
<p>
作为使用 std::bind 模仿移动捕获的第二个例子，这里是我们之前看到的在 C++14，闭包内创建 std::unique_ptr 的代码：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">pw</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">()]</span> <span class="c1">// as before,
</span><span class="c1"></span>  <span class="p">{</span> <span class="k">return</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isValidated</span><span class="p">()</span> <span class="c1">// create pw
</span><span class="c1"></span>	<span class="o">&amp;&amp;</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isArchived</span><span class="p">();</span> <span class="p">};</span> <span class="c1">// in closure
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这是 C++11 的模仿物：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span>
	  <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">pw</span><span class="p">)</span>
	  <span class="p">{</span> <span class="k">return</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isValidated</span><span class="p">()</span>
		<span class="o">&amp;&amp;</span> <span class="n">pw</span><span class="o">-&gt;</span><span class="n">isArchived</span><span class="p">();</span> <span class="p">},</span>
	  <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">()</span>
	  <span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
我展示了如何使用 std::bind 来绕开 C++11 的 lambda 的限制，这是很讽刺的，因为在条款 34 中，我提倡尽量使用 lambda 来代替 std::bind。
但是，那条款解释了，在 C++11 的某些情况 std::bind 是有用的，这里就是其中一个例子。（在 C++14，初始化捕获和 auto 形参这两个特性可以消除那些情况。）
</p>
<h2 id="headline-4">
记住
</h2>
<ul>
<li>
<p>
使用 C++14 的初始化捕获来把对象移到到闭包。
</p>
</li>
<li>
<p>
在 C++11，借助手写类或 std::bind 模仿初始化捕获。
</p>
</li>
</ul>
<h1 id="headline-5">
参考
</h1>
<p>
原文：effective-modern-c++
翻译：<a href="http://blog.csdn.net/big_yellow_duck/article/category/6352345">http://blog.csdn.net/big_yellow_duck/article/category/6352345</a>
</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Hardy Li</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2018-01-11
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/c&#43;&#43;-ep15lambda-epressions2/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">C&#43;&#43; Ep15:Lambda Epressions(2)</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/c&#43;&#43;-ep13rvalue-referencesmove-semanticsand-perfect-forwarding5/">
            <span class="next-text nav-default">C&#43;&#43; Ep13:Rvalue References,Move Semantics,and Perfect Forwarding(5)</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
      <a href="http://localhost:1313" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="http://localhost:1313" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://hardy5012.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Hardy Li</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
