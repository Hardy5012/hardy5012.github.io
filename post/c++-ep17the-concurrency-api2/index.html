<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.57.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>C&#43;&#43; Ep17:The Concurrency API(2) | Learning Hardy</title>
    <meta property="og:title" content="C&#43;&#43; Ep17:The Concurrency API(2) - Learning Hardy">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2018-01-17T00:00:00&#43;08:00">
        
        
    <meta property="article:modified_time" content="2018-01-17T00:00:00&#43;08:00">
        
    <meta name="Keywords" content="">
    <meta name="description" content="C&#43;&#43; Ep17:The Concurrency API(2)">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://hardy5012.github.io/post/c&#43;&#43;-ep17the-concurrency-api2/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://hardy5012.github.io/">
                        Learning Hardy
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://hardy5012.github.io/">首页</a>
                    
                    <a  href="https://hardy5012.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://hardy5012.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">C&#43;&#43; Ep17:The Concurrency API(2)</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2018年1月17日
                        </date>
                        
                        <div class="post-meta">
                            <span>|</span>
                            
                                <span class="meta-category"><a href="https://hardy5012.github.io/categories/modern">Modern</a></span>
                            
                                <span class="meta-category"><a href="https://hardy5012.github.io/categories/c&#43;&#43;">C&#43;&#43;</a></span>
                            
                        </div>
                        
                        
                        
                        <div class="post-content">
                            
<h1 id="headline-1">
Item 37:让 std::thread 对象在所有路径都无法连接
</h1>
<p>
每个 std::thread 对象的状态都是这两种中的一种：joinable（可连接的）或 unjoinable（不可连接的）。一个可连接的 std::thread 对应一个底层异步执行线程，
例如，一个 std::thread 对应的一个底层线程，它会被阻塞或等待被调度，
那么这个 std::thread 就是可连接的。std::thread 对象对应的底层线程可以将代码运行至结束，也可将其视为可连接的。
</p>
<!-- more -->
<p>
不可连接的 std::thread 的意思就如你想象那样：std::thread 不是可连接的。不可连接的 std::thread 对象包括：
</p>
<ul>
<li>
<p>
默认构造的 std::thread。这种 std::thread 没有函数可以执行，因此没有对应的底层执行线程。
</p>
</li>
<li>
<p>
被移动过的 std::thread。移动的结果是，一个 std::thread 对应的底层执行线程被对应到另一个 std::thread。
</p>
</li>
<li>
<p>
被连接过（调用了 join）的 std::thread。在调用了 join 之后，std::thread 对应的底层执行线程结束运行，就没有对应的底层线程了
</p>
</li>
<li>
<p>
被分离（detach）的 std::thread。detach 把 std::thread 对象与它对应的底层执行线程分离开。
</p>
</li>
</ul>
<p>
std::thread 的连接性是很重要的，其中一个原因是：如果一个可连接的线程对象执行了析构操作，那么程序会被终止。
例如，假设我们有一个函数 doWork，它的参数包含过滤器函数 filter、一个最大值 maxVal。doWork 把 0 到 maxVal 之间值传给过滤器，
然后满足特定条件就对满足过滤器的值进行计算。如果执行过滤器函数是费时的，而检查条件也是费时的，那么并发做这两件事是合理的。
</p>
<p>
我们其实会更偏向于使用基于任务的设计（看条款 35），但是让我们假定我们想要设置执行过滤器线程的优先级。
条款 35 解释过请求使用线程的本机句柄（native handle）时，只能通过 std::thread 的 API；基于任务的 API 没有提供这个功能。
因此我们的方法是基于线程，而不是基于任务。
</p>
<p>
我们可以提出这样的代码：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">auto</span> tenMillion <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000000</span>; <span style="color:#75715e">// see Item 15
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// for constexpr
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">doWork</span>(std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;</span> filter, <span style="color:#75715e">// returns whether
</span><span style="color:#75715e"></span>			  <span style="color:#66d9ef">int</span> maxVal <span style="color:#f92672">=</span> tenMillion) <span style="color:#75715e">// computation was
</span><span style="color:#75715e"></span>  { <span style="color:#75715e">// performed; see
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Item 2 for
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// std::function
</span><span style="color:#75715e"></span>	  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> goodVals; <span style="color:#75715e">// values that
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// satisfy filter
</span><span style="color:#75715e"></span>	  std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t([<span style="color:#f92672">&amp;</span>filter, maxVal, <span style="color:#f92672">&amp;</span>goodVals] <span style="color:#75715e">// populate
</span><span style="color:#75715e"></span>					{ <span style="color:#75715e">// goodVals
</span><span style="color:#75715e"></span>						<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> maxVal; <span style="color:#f92672">++</span>i)
						{ <span style="color:#66d9ef">if</span> (filter(i)) goodVals.push_back(i); }
							});
	  <span style="color:#66d9ef">auto</span> nh <span style="color:#f92672">=</span> t.native_handle(); <span style="color:#75715e">// use t&#39;s native
</span><span style="color:#75715e"></span>	  <span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// handle to set
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// t&#39;s priority
</span><span style="color:#75715e"></span>		  <span style="color:#66d9ef">if</span> (conditionsAreSatisfied()) {
			  t.join(); <span style="color:#75715e">// let t finish
</span><span style="color:#75715e"></span>			  performComputation(goodVals);
			  <span style="color:#66d9ef">return</span> true; <span style="color:#75715e">// computation was
</span><span style="color:#75715e"></span>		  } <span style="color:#75715e">// performed
</span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">return</span> false; <span style="color:#75715e">// computation was
</span><span style="color:#75715e"></span>  } <span style="color:#75715e">// not performed
</span></code></pre></div>
</div>
<p>
在我解释这个代码为什么有问题之前，我想提一下 <strong>tenMillion</strong> 的初始值在 C++14 可以变得更有可读性，利用 C++14 的能力，把单引号作为数字的分隔符：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">auto</span> tenMillion <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span><span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#ae81ff">000</span><span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#ae81ff">000</span>; <span style="color:#75715e">// C++14
</span></code></pre></div>
</div>
<p>
我还想提一下在线程 t 开始执行之后才去设置它的优先级，这有点像众所周知的马脱缰跑了后你才关上门。
一个更好设计是以暂停状态启动线程 t（因此可以在执行之前修改它的优先级），但我不想那部分的代码使你分心。
如果你已经严重分心了，那么请去看条款 39，因为那里展示了如何启动暂停的线程。
</p>
<p>
回到 doWork，如果 <strong>conditionsAreSatisfied()</strong> 返回 true，那么没问题，但如果返回 false 或者抛出异常，那么在 doWork 的末尾，
调用 std::thread 的析构函数时，它状态是可连接的，那会导致执行中的程序被终止。
</p>
<p>
你可能想知道 std::thread 的析构函数为什么会表现出这种行为，那是因为另外两种明显的选项会更糟。它们是：
</p>
<ul>
<li>
<p>
<strong>隐式连接</strong> （join）。在这种情况下，std::thread 的析构函数会等待底层异步执行线程完成工作。这听起来合情合理，但是这会导致难以追踪的性能异常。例如，如果 conditionAreSatisfied()已经返回 false 了，doWork 函数还要等待过滤器函数的那个循环，这是违反直觉的。
</p>
</li>
<li>
<p>
<strong>隐式分离</strong> （detach)。在这种情况下，std::thread 的析构函数会分离 std::thread 对象与底层执行线程之间的连接，而那个底层执行线程会继续执行。这听起来和 join 那个方法一样合理，但它导致更难调试的问题。例如，在 doWork 中，goodVals 是个通过引用捕获的局部变量，它可以在 lambda 内被修改（通过 push_back），然后，假如当 lambda 异步执行时，conditionsAreSatisfied()返回 false。那种情况下，doWork 会直接返回，它的局部变量（包括 goodVals）会被销毁，doWork 的栈帧会被弹出，但是 <strong>线程仍然执行</strong> 。 在接着 doWork 调用端之后的代码中，某个时刻，会调用其它函数，而至少一个函数可能会使用一部分或者全部 doWork 栈帧占据过的内存，我们先把这个函数称为 f。当 f 运行时，doWork 发起的 lambda 依然会异步执行。lambda 在栈上对 goodVals 调用 push_back，不过如今是在 f 的栈帧中。这样的调用会修改过去属于 goodVals 的内存，而那意味着从 f 的角度看，栈帧上的内存内容会自己改变！想想看你调试这个问题时会有多滑稽。
</p>
</li>
</ul>
<p>
标准委员会任务销毁一个可连接的线程实在太恐怖了，所以从根源上禁止它（通过指定可连接的线程的析构函数会终止程序）
</p>
<p>
这就把责任交给了你，如果你使用了一个 std::thread 对象，你要确保在它定义的作用域外的任何路径，使它变为不可连接。但是覆盖任何路径是很复杂的，
它包括关闭流出范围然后借助 return、continue、break、goto 或异常来跳出，这有很多条路径。
</p>
<p>
任何时候你想要在每一条路径都执行一些动作，那么最常用的方法是在局部对象的析构函数中执行动作。这些对象被称为了 RAII 对象，
而产生它们的类被称为 RAII 类（RAII（ <strong>Resource Acquisition Is Initialization</strong> ）表示“资源获取就是初始化”，即使技术的关键是销毁，而不是初始化）
。RAII 类在标准库很常见，例子包括 STL 容器（每个容器的析构函数都会销毁容器的内容并释放内存）、
标准智能指针（条款 18-20 解释了 std::unique_ptr 析构函数会对它指向的对象调用删除器，
而 std::shared_ptr 和 std::weak_ptr 的析构函数会减少引用计数）、std::fstream 对象（它们的析构函数会关闭对应的文件），而且还有很多。
然而，没有关于 std::thread 的标准 RAII 类，可能是因为标准委员会拒绝把 join 或 detach 作为默认选项，这仅仅是不知道如何实现这样类。
</p>
<p>
幸运的是，你自己写一个不会很难。例如，下面这个类，允许调用者指定 ThreadRAII 对象（一个 std::thread 的 RAII 对象）销毁时调用 join 或者 detach：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">ThreadRAII</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">DtorAction</span> { join, detach }; <span style="color:#75715e">// see Item 10 for
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// enum class info
</span><span style="color:#75715e"></span>	  ThreadRAII(std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span><span style="color:#f92672">&amp;&amp;</span> t, DtorAction a) <span style="color:#75715e">// in dtor, take
</span><span style="color:#75715e"></span>		  <span style="color:#f92672">:</span> action(a), t(std<span style="color:#f92672">::</span>move(t)) {} <span style="color:#75715e">// action a on t
</span><span style="color:#75715e"></span>	  <span style="color:#f92672">~</span>ThreadRAII()
		  { <span style="color:#75715e">// see below for
</span><span style="color:#75715e"></span>			  <span style="color:#66d9ef">if</span> (t.joinable()) { <span style="color:#75715e">// joinability test
</span><span style="color:#75715e"></span>				  <span style="color:#66d9ef">if</span> (action <span style="color:#f92672">==</span> DtorAction<span style="color:#f92672">::</span>join) {
					  t.join();
				  } <span style="color:#66d9ef">else</span> {
					  t.detach();
				  }
			  }
		  }
	  std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span><span style="color:#f92672">&amp;</span> get() { <span style="color:#66d9ef">return</span> t; } <span style="color:#75715e">// see below
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	  DtorAction action;
	  std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t;
  };
</code></pre></div>
</div>
<p>
我希望这份代码是一目了然的，但下面的几点可能对你有帮助：
</p>
<ul>
<li>
<p>
构造函数只接受右值的 std::thread，因为我们想要把传进来的 std::thread 对象移动到 ThreadRAII 对象里。（std::thread 是不能被拷贝的类型。）
</p>
</li>
<li>
<p>
对于调用者，构造函数的形参顺序的设计十分直观（指定 std::thread 作为第一个参数，而销毁动作作为第二个参数，比起反过来直观很多），但是，成员初始化列表被设计来匹配成员变量声明的顺序，成员变量的顺序是把 std::thread 放到最后。在这个类中，这顺序不会导致什么不同，不过一般来说，一个成员变量的初始化有可能依赖另一个成员变量，而因为 std::thread 对象初始化之后可能会马上运行函数，所以把它们声明在一个类的最后是一个很好的习惯。那保证了当 std::thread 构造的时候，所有在它之前的成员变量都已经被初始化，因此 std::thread 成员变量对应的底层异步执行线程可以安全地取得它们。
</p>
</li>
<li>
<p>
ThreadRAII 提供了一个 get 函数，它是一个取得内部 std::thread 对象的入口，这类似于标准智能指针提供了 get 函数（它提供了取得内部原生指针的入口）。提供 get 可以避免 ThreadRAII 复制 std::thread 的所有接口，而这也意味着 ThreadRAII 可以用于请求 std::thread 对象的上下文。
</p>
</li>
<li>
<p>
ThreadRAII 的析构函数在调用 std::thread 对象 t 的成员函数之前，它先检查确保 t 是可连接的。这是必需的，因为对一个不可连接的线程调用 join 或 detach 会产生未定义行为。某个用户构建了一个 std::thread，然后用它创建 ThreadRAII 对象，再使用 get 请求获得 t，接着移动 t 或者对 t 调用 join 或 detach，这是有可能发生的，而这样的行为会导致 t 变得不可连接。
</p>
</li>
</ul>
<p>
如果你担心这代码， 
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">if</span> (t.joinable()) {
	  <span style="color:#66d9ef">if</span> (action <span style="color:#f92672">==</span> DtorAction<span style="color:#f92672">::</span>join) {
		  t.join();
	  } <span style="color:#66d9ef">else</span> {
		  t.detach();
	  }
  }
</code></pre></div>
</div>
<p>
存在竞争，因为在 t.joinable()和调用 join 或 detach 之间，另一个线程可能让 t 变得不可连接。你的直觉是值得赞扬的，但是你的害怕是没有根据的。
一个 std::thread 对象只能通过调用成员函数来从可连接状态转换为不可连接状态，例如，join、detach 或移动操作。当 <strong>ThreadRAII</strong> 对象的析构函数被调用时，
不应该有其他线程调用该对象的成员函数。如果这两个函数同时发生，那的确是竞争，但竞争没有发生在析构函数内，
它是发生在试图同时调用两个成员函数（析构函数和其他）的用户代码内。一般来说，对于一个对象同时调用两个成员函数，
也只有是 const 成员函数（看条款 16）才能确保线程安全。
</p>
<p>
在我们 doWork 的例子中使用 ThreadRAII，代码是这样的：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">doWork</span>(std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;</span> filter, <span style="color:#75715e">// as before
</span><span style="color:#75715e"></span>			  <span style="color:#66d9ef">int</span> maxVal <span style="color:#f92672">=</span> tenMillion)
  {
	  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> goodVals; <span style="color:#75715e">// as before
</span><span style="color:#75715e"></span>	  ThreadRAII t( <span style="color:#75715e">// use RAII object
</span><span style="color:#75715e"></span>		  std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span>([<span style="color:#f92672">&amp;</span>filter, maxVal, <span style="color:#f92672">&amp;</span>goodVals]
					  {
						  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> maxVal; <span style="color:#f92672">++</span>i)
						  { <span style="color:#66d9ef">if</span> (filter(i)) goodVals.push_back(i); }
					  }),
		  ThreadRAII<span style="color:#f92672">::</span>DtorAction<span style="color:#f92672">::</span>join <span style="color:#75715e">// RAII action
</span><span style="color:#75715e"></span>		  );
	  <span style="color:#66d9ef">auto</span> nh <span style="color:#f92672">=</span> t.get().native_handle();
	  <span style="color:#960050;background-color:#1e0010">…</span>
		  <span style="color:#66d9ef">if</span> (conditionsAreSatisfied()) {
			  t.get().join();
			  performComputation(goodVals);
			  <span style="color:#66d9ef">return</span> true;
		  }
	  <span style="color:#66d9ef">return</span> false;
  }
</code></pre></div>
</div>
<p>
在这个例子中，我们选择在 ThreadRAII 析构函数中，对异步执行线程调用 join 函数，因为我们之前看到，调用 detach 函数会导致一些恶梦般的调试。
我们之前也看到过 join 会导致性能异常（实话说，那调试起来也很不爽），但在未定义行为（detach 给的）、程序终止（使用原始 std::thread 会产生）、
性能异常之前做出选择，性能异常就像是瘸子里面挑出的将军 。
</p>
<p>
额，条款 39 展示了使用 ThreadRAII 在 std::thread 销毁中进行 join 不会导致性能异常，而是导致挂起程序。这种问题的“合适的”解决方案是：
和异步执行的 lambda 进行交流，当我们不需要它时候，它可以早早的返回；但 C++11 不支持这种可中断的线程。我们可以手动实现它们，
但那个话题已经超越了这本书的范围了（在《C++并发编程实战》的章节 9.2 可以找到）。
</p>
<p>
条款 17 解释过，因为 ThreadRAII 声明了析构函数，所以不会有编译器生成的移动操作，但这里 ThreadRAII 对象没有理由不能移动。
如果编译器生成的这些函数，这些函数的可以行为是正确的，所以显示请求创建它们是适合的：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">ThreadRAII</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">DtorAction</span> { join, detach }; <span style="color:#75715e">// as before
</span><span style="color:#75715e"></span>	  ThreadRAII(std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span><span style="color:#f92672">&amp;&amp;</span> t, DtorAction a) <span style="color:#75715e">// as before
</span><span style="color:#75715e"></span>		  <span style="color:#f92672">:</span> action(a), t(std<span style="color:#f92672">::</span>move(t)) {}
	  <span style="color:#f92672">~</span>ThreadRAII()
		  {
			  <span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// as before
</span><span style="color:#75715e"></span>				  }
	  ThreadRAII(ThreadRAII<span style="color:#f92672">&amp;&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>; <span style="color:#75715e">// support
</span><span style="color:#75715e"></span>	  ThreadRAII<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(ThreadRAII<span style="color:#f92672">&amp;&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>; <span style="color:#75715e">// moving
</span><span style="color:#75715e"></span>	  std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span><span style="color:#f92672">&amp;</span> get() { <span style="color:#66d9ef">return</span> t; } <span style="color:#75715e">// as before
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span> <span style="color:#75715e">// as before
</span><span style="color:#75715e"></span>	  DtorAction action;
	  std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t;
  };
</code></pre></div>
</div>
<h2 id="headline-2">
记住
</h2>
<ul>
<li>
<p>
在所有路径上，让 std::thread 变得不可连接。 
</p>
</li>
<li>
<p>
在销毁时用 join 会导致难以调试的性能异常。
</p>
</li>
<li>
<p>
在销毁时用 detach 会导致难以调试的未定义行为。
</p>
</li>
<li>
<p>
在成员变量列表最后声明 std::thread。
</p>
</li>
</ul>
<h1 id="headline-3">
Item38: 意识到线程句柄的析构函数的不同行为
</h1>
<p>
条款 37 解释过一个可连接的（joinable）线程对应着一个底层的系统执行线程，
一个非推迟任务（看条款 36）的 future 和系统线程也有类似的关系。
这样的话，可以认为 std::thread 对象和 future 对象都可以操纵系统线程。
</p>
<p>
从这个角度看，std::thread 对象和 future 对象的析构函数表现出不同的行为是很有趣的。就如条款 37 提到，
销毁一个可连接的 std::thread 对象会终止你的程序
，因为另外两个选择——隐式 join 和隐式 detach——被认为是更糟的选择。
而销毁一个 future，有时候会表现为隐式 join，有时候会表现为隐式 detach，
有时候表现的行为既不是 join 也不是 detach。它决不会导致程序终止，这种线程管理行为的方法值得我们仔细检查。
</p>
<p>
我们从观察一个 future 开始吧，它是一个交流管道的一端，在这个交流管道中被叫方要把结果传给主叫方。
被叫方（通常异步运行）把计算的结果写进交流管道
（通常借助一个 <strong>std::promise</strong> 对象），而主叫方使用一个 future 来读取结果。
你可以用下图来思考，虚线箭头展示了信息被叫这流向主叫：
</p>
<p>
<img src="C++ Ep17:The Concurrency API(2)/screenshot_2018-01-29_18-00-47.png" alt="C++ Ep17:The Concurrency API(2)/screenshot_2018-01-29_18-00-47.png" title="C++ Ep17:The Concurrency API(2)/screenshot_2018-01-29_18-00-47.png" />
但被叫方的结果存储在哪里呢？在主叫方 future 执行 get 之前，被叫方可能已经执行完了，
因此结果不能存储在被叫的 std::promise 里。
那个对象，会是被叫方的局部变量，在被叫执行结束后会被销毁
</p>
<p>
然而，结果也不能存储在主叫方的 future 中，因为（还有其他原因）一个 std::future 
对象可能被用来创建一个 <strong>std::shared_future</strong> 
（因此把被叫方结果的所有权从 std::future 转移到 std::shared_future），
而在最原始的 std::future 销毁之后，这个 std::shared_future 
可能会被拷贝很多次。倘若被叫方的结果类型是不可被拷贝的（即只可移动类型），而那结果是只要有一个 future 引用它，它就会存在，
那么，多个 future 中哪一个含有被叫方的结果呢？
</p>
<p>
因为被叫方对象和主叫方对象都不适合存储结构，所以这个结果存在两者之外的地方。
这个地方叫做 <strong>shared state</strong> ，shared state 通常表现为一个基于堆实现的对象，
但标准没有指定它的类型、接口和实现，所以标准库的作者可以用他们喜欢的方法来实现 shared state。
</p>
<p>
如下，我们可以把主叫、被叫、shared state 之间的关系视图化，虚线箭头再次表现信息的流向：
</p>
<p>
<img src="C++ Ep17:The Concurrency API(2)/screenshot_2018-01-29_18-05-02.png" alt="C++ Ep17:The Concurrency API(2)/screenshot_2018-01-29_18-05-02.png" title="C++ Ep17:The Concurrency API(2)/screenshot_2018-01-29_18-05-02.png" />
shared state 的存在很重要，因为 future 的析构函数的行为——该条款的话题——是由与它关联的 shared state 决定的。特别是：
</p>
<ul>
<li>
<p>
<span style="text-decoration: underline;">最后一个引用 shared state（它借助 std::aysnc 创建了一个非推迟任务时产生）的 future 的析构函数会阻塞直到任务完成</span> 。本质上，这种 future 的析构函数对底层异步执行任务的线程进行隐式的 join。
</p>
</li>
<li>
<p>
<span style="text-decoration: underline;">其他的 future 对象的析构函数只是简单地销毁 future 对象</span> 。对于底层异步运行的任务，与对线程进行 detach 操作相似。对于最后一个 future 是推迟的任务的情况，这意味着推迟的任务将不会运行。
</p>
</li>
</ul>
<p>
这些规则听起来很复杂，但我们真正需要处理的是一个简单“正常的”行为和一个单独的例外而已。这正常的行为是：future 的析构函数会销毁 future 对象。
那意思是，它不会 <strong>join</strong> 任何东西，也不会 <strong>detach</strong> 任何东西，它也没有运行任何东西，它只是销毁 future 的成员变量。
（好吧。实际上，它还多做了些东西。它减少了 shared state 里的引用计数，这个 shared state 由 future 和被叫的  <strong>std::promise</strong>  共同操控。
引用计数可以让库知道什么时候销毁 shared state，关于引用计数的通用知识，请看条款 19.）
</p>
<p>
对于正常行为的那个例外，只有在 future 满足下面全部条件才会出现：
</p>
<ul>
<li>
<p>
<span style="text-decoration: underline;">future 引用的 shared state 是在调用了 std::async 时被创建</span> 。
</p>
</li>
<li>
<p>
<span style="text-decoration: underline;">任务的发射策略是 std::launch::async（看条款 36）</span> ，要么是运行时系统选择的，要么是调用 std::async 时指定的。
</p>
</li>
<li>
<p>
<span style="text-decoration: underline;">这个 future 是最后一个引用 shared state 的 future</span> 。对于 std::future，它总是最后一个，而对于 std::shared_future，当它们被销毁的时候，如果它们不是最后一个引用 shared state 的 future，那么它们会表现出正常的行为（即，销毁成员变量）
</p>
</li>
</ul>
<p>
只有当这些条件都被满足时，future 的析构函数才会表现出特殊的行为，而这行为是： <span style="text-decoration: underline;">阻塞直到异步运行的任务结束</span> 。特别说明一下，
这相当于对运行着 <strong>std::async</strong> 创建的任务的线程执行 <strong>隐式 join</strong> 。
</p>
<p>
这个例外对于正常的 future 析构函数行为来说，可以总结为“来自 std::async 的 future 在它们的析构函数里阻塞了。”对于初步近似，它是正确的，
但有时候你需要的比初步近似要多，现在你已经知道了它所有的真相了。
</p>
<p>
你可能又有另一种疑问，可能是“我好奇为什么会有这么奇怪的规则？”。这是个合理的问题，关于这个我只能告诉你，标准委员会想要避免隐式 detach 引发的问题
（看条款 37），但是他们又不想用原来的策略让程序终止（针对可连接的线程，看条款 37），所以他们对隐式 join 妥协了。
这个决定不是没有争议的，他们也有讨论过要在 C++14 中禁止这种行为。但最后，没有改变，所以 future 析构函数的行为在 C++11 和 C++14 相同。
</p>
<p>
future 的 API 没有提供方法判断 future 引用的 shared state 是否产生于 std::async 调用，所以给定任意的 future 对象，
不可能知道它的析构函数是否会阻塞到异步执行任务的结束。这有一些有趣的含义：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#75715e">// this container might block in its dtor, because one or more
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// contained futures could refer to a shared state for a non-
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// deferred task launched via std::async
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;&gt;</span> futs; <span style="color:#75715e">// see Item 39 for info
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// on std::future&lt;void&gt;
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">Widget</span> { <span style="color:#75715e">// Widget objects might
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span> <span style="color:#75715e">// block in their dtors
</span><span style="color:#75715e"></span>	  <span style="color:#960050;background-color:#1e0010">…</span>
	  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	  std<span style="color:#f92672">::</span>shared_future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> fut;
  };
</code></pre></div>
</div>
<p>
当然，如果你有办法知道给定的 future 不满足触发特殊析构行为的条件（例如，通过程序逻辑），你就可以断定 future 不会阻塞在它的析构函数。
例如，只有在 std::async 调用时出现的 shared state 才具有特殊行为的资格，但是有其他方法可以创建 shared state。
一个是 <strong>std::packaged_task</strong> 的使用，一个 std::packaged_task 对象包装一个可调用的对象，并且允许异步执行并获取该可调用对象产生的结果，
这个结果就被放在 shared state 里。引用 shared state 的 future 可以借助 std::packaged_task 的 get_future 函数获取：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">calcValue</span>(); <span style="color:#75715e">// func to run
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>packaged_task<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>()<span style="color:#f92672">&gt;</span> <span style="color:#75715e">// wrap calcValue so it
</span><span style="color:#75715e"></span>  pt(calcValue); <span style="color:#75715e">// can run asynchronously
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> fut <span style="color:#f92672">=</span> pt.get_future(); <span style="color:#75715e">// get future for pt
</span></code></pre></div>
</div>
<p>
在这时，我们知道 future 对象 fut 没有引用由 std::async 调用的产生的 shared state，所以它的析构函数将会表现出正常的行为。
</p>
<p>
一旦 std::packaged_task 对象 pt 被创建，它就会被运行在线程中。（它也可以借助 std::async 调用，但是如果你想要用 std::async 运行一个任务，
没有理由创建一个 std::packaged_task 对象，因为 std::async 能做 std::packaged_task 能做的任何事情。）
</p>
<p>
std::packaged_task 不能被拷贝，所以当把 pt 传递给一个 std::thread 构造函数时，它一定要被转换成一个右值（借助 std::move——看条款 23）：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t(std<span style="color:#f92672">::</span>move(pt)); <span style="color:#75715e">// run pt on t
</span></code></pre></div>
</div>
<p>
这个例子让我们看到了一些 future 正常析构行为，但如果把这些语句放在同一个块中，就更容易看出来：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  { <span style="color:#75715e">// begin block
</span><span style="color:#75715e"></span>	  std<span style="color:#f92672">::</span>packaged_task<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>()<span style="color:#f92672">&gt;</span>
		  pt(calcValue);
	  <span style="color:#66d9ef">auto</span> fut <span style="color:#f92672">=</span> pt.get_future();
		  std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t(std<span style="color:#f92672">::</span>move(pt));
	  <span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// see below
</span><span style="color:#75715e"></span>		  } <span style="color:#75715e">// end block
</span></code></pre></div>
</div>
<p>
这里最有趣的代码是“…”，它在块结束之前，t 创建之后。这里有趣的地方是在“…”中，t 会发生什么。有 3 个基本的可能
</p>
<ul>
<li>
<p>
<span style="text-decoration: underline;">t 什么都没做</span> 。在这种情况下，t 在作用域结束时是可连接的（joinable），这将会导致程序终止（看条款 37）。
</p>
</li>
<li>
<p>
<span style="text-decoration: underline;">t 进行了 join 操作</span> 。在这种情况下，fut 就不需要在析构时阻塞了，因为代码已经 join 了
</p>
</li>
<li>
<p>
<span style="text-decoration: underline;">t 进行了 detach 操作</span> 。在这种情况下，fut 就不需要在析构时 detach 了，因为代码已经做了这件事了。
</p>
</li>
</ul>
<p>
换句话说，当你 shared state 对应的 future 是由 <strong>std::packaged_task</strong> 产生的，通常不需要采用特殊析构策略，
因为操纵运行 std::packaged_task 的 std::thread 的代码会在终止、join、detach 之间做出决定
</p>
<h2 id="headline-4">
记住
</h2>
<ul>
<li>
<p>
future 的析构函数通常只是销毁 future 的成员变量。
</p>
</li>
<li>
<p>
最后一个引用 shared state（它是在借助 std::aysnc 创建了一个非推迟任务时产生）的 future 会阻塞到任务完成。
</p>
</li>
</ul>
<h1 id="headline-5">
参考
</h1>
<p>
原文：effective-modern-c++
翻译：<a href="http://blog.csdn.net/big_yellow_duck/article/category/635234">http://blog.csdn.net/big_yellow_duck/article/category/635234</a>
</p>

                        </div>

                        


                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/c&#43;&#43;-ep16the-concurrency-api1/">C&#43;&#43; Ep16:The Concurrency API(1)</a></li>
        
        <li><a href="/post/c&#43;&#43;-ep15lambda-epressions2/">C&#43;&#43; Ep15:Lambda Epressions(2)</a></li>
        
        <li><a href="/post/c&#43;&#43;-ep14lambda-epressions1/">C&#43;&#43; Ep14:Lambda Epressions(1)</a></li>
        
        <li><a href="/post/c&#43;&#43;-ep13rvalue-referencesmove-semanticsand-perfect-forwarding5/">C&#43;&#43; Ep13:Rvalue References,Move Semantics,and Perfect Forwarding(5)</a></li>
        
        <li><a href="/post/c&#43;&#43;-ep12rvalue-referencesmove-semanticsand-perfect-forwarding4/">C&#43;&#43; Ep12:Rvalue References,Move Semantics,and Perfect Forwarding(4)</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="https://hardy5012.github.io/tags/c&#43;&#43;">C&#43;&#43;</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://hardy5012.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://hardy5012.github.io/post/%E4%B8%BA%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/" title="为运行的容器挂载文件目录">为运行的容器挂载文件目录</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/super%E6%B2%A1%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95/" title="super 没那么简单">super 没那么简单</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/postgres%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D%E5%88%86%E9%A1%B5%E6%96%B9%E5%BC%8F/" title="Postgres 中的五种分页方式">Postgres 中的五种分页方式</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/c&#43;&#43;-ep23-if-constexpt/" title="C&#43;&#43; Ep23: constexpr if">C&#43;&#43; Ep23: constexpr if</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/c&#43;&#43;-ep22-fibonacci/" title="C&#43;&#43; Ep22: Fibonacci">C&#43;&#43; Ep22: Fibonacci</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/c&#43;&#43;-ep21-variadic-templates/" title="C&#43;&#43; Ep21: variadic Templates">C&#43;&#43; Ep21: variadic Templates</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/c&#43;&#43;-ep20-static-variable/" title="C&#43;&#43; Ep20: Static Variable">C&#43;&#43; Ep20: Static Variable</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/tweaks2/" title="Tweaks(2)">Tweaks(2)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/tweaks1/" title="Tweaks(1)">Tweaks(1)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/post/c&#43;&#43;-ep19the-concurrency-api4/" title="C&#43;&#43; Ep19:The Concurrency API(4)">C&#43;&#43; Ep19:The Concurrency API(4)</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://hardy5012.github.io/categories/ai/">ai(5)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/categories/c&#43;&#43;/">c&#43;&#43;(20)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/categories/date/">date(1)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/categories/modern/">modern(16)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/categories/notes/">notes(10)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/categories/summary/">summary(5)</a>
    </li>
    
    <li>
        <a href="https://hardy5012.github.io/categories/weekly/">weekly(4)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://hardy5012.github.io/tags/boost/">boost</a>
    
    <a href="https://hardy5012.github.io/tags/c&#43;&#43;/">c&#43;&#43;</a>
    
    <a href="https://hardy5012.github.io/tags/constexpr/">constexpr</a>
    
    <a href="https://hardy5012.github.io/tags/docker/">docker</a>
    
    <a href="https://hardy5012.github.io/tags/etf/">etf</a>
    
    <a href="https://hardy5012.github.io/tags/fibonacci/">fibonacci</a>
    
    <a href="https://hardy5012.github.io/tags/git/">git</a>
    
    <a href="https://hardy5012.github.io/tags/gprof/">gprof</a>
    
    <a href="https://hardy5012.github.io/tags/heroku/">heroku</a>
    
    <a href="https://hardy5012.github.io/tags/linear/">linear</a>
    
    <a href="https://hardy5012.github.io/tags/linux/">linux</a>
    
    <a href="https://hardy5012.github.io/tags/logistic/">logistic</a>
    
    <a href="https://hardy5012.github.io/tags/makefile/">makefile</a>
    
    <a href="https://hardy5012.github.io/tags/neural/">neural</a>
    
    <a href="https://hardy5012.github.io/tags/postgrespaginate/">postgrespaginate</a>
    
    <a href="https://hardy5012.github.io/tags/protobuf/">protobuf</a>
    
    <a href="https://hardy5012.github.io/tags/python/">python</a>
    
    <a href="https://hardy5012.github.io/tags/regression/">regression</a>
    
    <a href="https://hardy5012.github.io/tags/regularization/">regularization</a>
    
    <a href="https://hardy5012.github.io/tags/spacemacs/">spacemacs</a>
    
    <a href="https://hardy5012.github.io/tags/static/">static</a>
    
    <a href="https://hardy5012.github.io/tags/template/">template</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://hardy5012.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="https://hardy5012.github.io/">Learning Hardy By </a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>






</body>
</html>
