

There are two possible situations that led to this error:
  1. You haven&#39;t copied the config.toml yet. See https://github.com/olOwOlo/hugo-theme-even#installation 
  2. You have an incompatible update. See https://github.com/olOwOlo/hugo-theme-even/blob/master/CHANGELOG.md#400-2018-11-06 

有两种可能的情况会导致这个错误发生:
  1. 你还没有复制 config.toml 参考 https://github.com/olOwOlo/hugo-theme-even/blob/master/README-zh.md#installation 
  2. 你进行了一次不兼容的更新 参考 https://github.com/olOwOlo/hugo-theme-even/blob/master/CHANGELOG.md#400-2018-11-06 
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; Ep04:Moving to Modern C&#43;&#43;(2) - Learning Hardy</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="item 11: 优先考虑使用 deleted function 而非 private undefined   在 C&#43;&#43; 98 中禁止拷贝和赋值实现如下： template &amp;lt;classcharT, classtraits = char_traits&amp;lt;charT&amp;gt; &amp;gt; classbasic_ios : public ios_base { public: … private: basic_ios(const basic_ios&amp;amp; ); // not defined 	basic_ios&amp;amp; operator=(const basic_ios&amp;amp;); // not defined  };    In C&#43;&#43;11,可使用 = delete template &amp;lt;classcharT, classtraits = char_traits&amp;lt;charT&amp;gt; &amp;gt; classbasic_ios : public ios_base { public: … basic_ios(const basic_ios&amp;amp; ) = delete; basic_ios&amp;amp; operator=(const basic_ios&amp;amp;) = delete; … };    delete 还可以删除实例化模板 template&amp;lt;typename T&amp;gt; void processPointer(T* ptr); template&amp;lt;&amp;gt; void processPointer&amp;lt;void&amp;gt;(void*) = delete; template&amp;lt;&amp;gt; void processPointer&amp;lt;char&amp;gt;(char*) = delete;   记住     优先考虑使用 deleted function 而非 private undefined    任何函数都能被删除（deleted），包括非成员函数和 template 实例化函数   item 12: 把重写函数声明为“override”   因为 overriding (重写)听起来有点像 overloading (重载)，但是他们完全没有关系，让我们来弄清楚，重写虚函数是为了通过基类的接口来调用派生类的函数。 classBase { public: virtual void doWork(); // base class virtual function 	… }; classDerived: public Base { public: virtual void doWork(); // overrides Base::doWork 	… // (&amp;#34;virtual&amp;#34; is optional  }; // here)  std::unique_ptr&amp;lt;Base&amp;gt; upb = // create base class pointer 	std::make_unique&amp;lt;Derived&amp;gt;(); // to derived class object;  // see Item 21 for info on  … // std::make_unique  upb-&amp;gt;doWork(); // call doWork through base  // class ptr; derived class  // function is invoked    为了能够成功重写，必须要符合一些要求：    基类函数必须是 virtual 的。    基类函数和派生类函数的名字必须完全一样（除了析构函数）    基类函数和派生类函数的参数类型必须完全一样。    基类函数和派生类函数的 const 属性必须完全一样。    类函数和派生类函数的返回值类型以及异常规格（exception specification）必须是可兼容的    这些限制是 C&#43;&#43;98 要求的，C&#43;&#43;11 还增加了一条:    函数的引用限定符必须完全一样    “成员函数引用限定符”是 C&#43;&#43;11 中不太被知道的特性，所以即使你从来没有听过，也不需要吃惊。 它们的出现是为了限制成员函数只能被左值或右值中的一个使用。使用它们时，不需要一定是 virtual 成员函数： classWidget { public: void doWork() &amp;amp;; // this version of doWork applies  // only when *this is an lvalue 	void doWork() &amp;amp;&amp;amp;; // this version of doWork applies  }; // only when *this is an rvalue  Widget makeWidget(); // factory function (returns rvalue)  Widget w; // normal object (an lvalue)  w." />






<meta name="generator" content="Hugo 0.57.0 with even 4.0.0" />


<link rel="canonical" href="https://hardy5012.github.io/post/c&#43;&#43;-ep04moving-to-modern-c&#43;&#43;2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">



<meta property="og:title" content="C&#43;&#43; Ep04:Moving to Modern C&#43;&#43;(2)" />
<meta property="og:description" content="item 11: 优先考虑使用 deleted function 而非 private undefined   在 C&#43;&#43; 98 中禁止拷贝和赋值实现如下： template &lt;classcharT, classtraits = char_traits&lt;charT&gt; &gt; classbasic_ios : public ios_base { public: … private: basic_ios(const basic_ios&amp; ); // not defined 	basic_ios&amp; operator=(const basic_ios&amp;); // not defined  };    In C&#43;&#43;11,可使用 = delete template &lt;classcharT, classtraits = char_traits&lt;charT&gt; &gt; classbasic_ios : public ios_base { public: … basic_ios(const basic_ios&amp; ) = delete; basic_ios&amp; operator=(const basic_ios&amp;) = delete; … };    delete 还可以删除实例化模板 template&lt;typename T&gt; void processPointer(T* ptr); template&lt;&gt; void processPointer&lt;void&gt;(void*) = delete; template&lt;&gt; void processPointer&lt;char&gt;(char*) = delete;   记住     优先考虑使用 deleted function 而非 private undefined    任何函数都能被删除（deleted），包括非成员函数和 template 实例化函数   item 12: 把重写函数声明为“override”   因为 overriding (重写)听起来有点像 overloading (重载)，但是他们完全没有关系，让我们来弄清楚，重写虚函数是为了通过基类的接口来调用派生类的函数。 classBase { public: virtual void doWork(); // base class virtual function 	… }; classDerived: public Base { public: virtual void doWork(); // overrides Base::doWork 	… // (&#34;virtual&#34; is optional  }; // here)  std::unique_ptr&lt;Base&gt; upb = // create base class pointer 	std::make_unique&lt;Derived&gt;(); // to derived class object;  // see Item 21 for info on  … // std::make_unique  upb-&gt;doWork(); // call doWork through base  // class ptr; derived class  // function is invoked    为了能够成功重写，必须要符合一些要求：    基类函数必须是 virtual 的。    基类函数和派生类函数的名字必须完全一样（除了析构函数）    基类函数和派生类函数的参数类型必须完全一样。    基类函数和派生类函数的 const 属性必须完全一样。    类函数和派生类函数的返回值类型以及异常规格（exception specification）必须是可兼容的    这些限制是 C&#43;&#43;98 要求的，C&#43;&#43;11 还增加了一条:    函数的引用限定符必须完全一样    “成员函数引用限定符”是 C&#43;&#43;11 中不太被知道的特性，所以即使你从来没有听过，也不需要吃惊。 它们的出现是为了限制成员函数只能被左值或右值中的一个使用。使用它们时，不需要一定是 virtual 成员函数： classWidget { public: void doWork() &amp;; // this version of doWork applies  // only when *this is an lvalue 	void doWork() &amp;&amp;; // this version of doWork applies  }; // only when *this is an rvalue  Widget makeWidget(); // factory function (returns rvalue)  Widget w; // normal object (an lvalue)  w." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hardy5012.github.io/post/c&#43;&#43;-ep04moving-to-modern-c&#43;&#43;2/" />
<meta property="article:published_time" content="2017-12-26T00:00:00+00:00" />
<meta property="article:modified_time" content="2017-12-26T00:00:00+00:00" />
<meta itemprop="name" content="C&#43;&#43; Ep04:Moving to Modern C&#43;&#43;(2)">
<meta itemprop="description" content="item 11: 优先考虑使用 deleted function 而非 private undefined   在 C&#43;&#43; 98 中禁止拷贝和赋值实现如下： template &lt;classcharT, classtraits = char_traits&lt;charT&gt; &gt; classbasic_ios : public ios_base { public: … private: basic_ios(const basic_ios&amp; ); // not defined 	basic_ios&amp; operator=(const basic_ios&amp;); // not defined  };    In C&#43;&#43;11,可使用 = delete template &lt;classcharT, classtraits = char_traits&lt;charT&gt; &gt; classbasic_ios : public ios_base { public: … basic_ios(const basic_ios&amp; ) = delete; basic_ios&amp; operator=(const basic_ios&amp;) = delete; … };    delete 还可以删除实例化模板 template&lt;typename T&gt; void processPointer(T* ptr); template&lt;&gt; void processPointer&lt;void&gt;(void*) = delete; template&lt;&gt; void processPointer&lt;char&gt;(char*) = delete;   记住     优先考虑使用 deleted function 而非 private undefined    任何函数都能被删除（deleted），包括非成员函数和 template 实例化函数   item 12: 把重写函数声明为“override”   因为 overriding (重写)听起来有点像 overloading (重载)，但是他们完全没有关系，让我们来弄清楚，重写虚函数是为了通过基类的接口来调用派生类的函数。 classBase { public: virtual void doWork(); // base class virtual function 	… }; classDerived: public Base { public: virtual void doWork(); // overrides Base::doWork 	… // (&#34;virtual&#34; is optional  }; // here)  std::unique_ptr&lt;Base&gt; upb = // create base class pointer 	std::make_unique&lt;Derived&gt;(); // to derived class object;  // see Item 21 for info on  … // std::make_unique  upb-&gt;doWork(); // call doWork through base  // class ptr; derived class  // function is invoked    为了能够成功重写，必须要符合一些要求：    基类函数必须是 virtual 的。    基类函数和派生类函数的名字必须完全一样（除了析构函数）    基类函数和派生类函数的参数类型必须完全一样。    基类函数和派生类函数的 const 属性必须完全一样。    类函数和派生类函数的返回值类型以及异常规格（exception specification）必须是可兼容的    这些限制是 C&#43;&#43;98 要求的，C&#43;&#43;11 还增加了一条:    函数的引用限定符必须完全一样    “成员函数引用限定符”是 C&#43;&#43;11 中不太被知道的特性，所以即使你从来没有听过，也不需要吃惊。 它们的出现是为了限制成员函数只能被左值或右值中的一个使用。使用它们时，不需要一定是 virtual 成员函数： classWidget { public: void doWork() &amp;; // this version of doWork applies  // only when *this is an lvalue 	void doWork() &amp;&amp;; // this version of doWork applies  }; // only when *this is an rvalue  Widget makeWidget(); // factory function (returns rvalue)  Widget w; // normal object (an lvalue)  w.">


<meta itemprop="datePublished" content="2017-12-26T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-12-26T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="869">



<meta itemprop="keywords" content="C&#43;&#43;," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; Ep04:Moving to Modern C&#43;&#43;(2)"/>
<meta name="twitter:description" content="item 11: 优先考虑使用 deleted function 而非 private undefined   在 C&#43;&#43; 98 中禁止拷贝和赋值实现如下： template &lt;classcharT, classtraits = char_traits&lt;charT&gt; &gt; classbasic_ios : public ios_base { public: … private: basic_ios(const basic_ios&amp; ); // not defined 	basic_ios&amp; operator=(const basic_ios&amp;); // not defined  };    In C&#43;&#43;11,可使用 = delete template &lt;classcharT, classtraits = char_traits&lt;charT&gt; &gt; classbasic_ios : public ios_base { public: … basic_ios(const basic_ios&amp; ) = delete; basic_ios&amp; operator=(const basic_ios&amp;) = delete; … };    delete 还可以删除实例化模板 template&lt;typename T&gt; void processPointer(T* ptr); template&lt;&gt; void processPointer&lt;void&gt;(void*) = delete; template&lt;&gt; void processPointer&lt;char&gt;(char*) = delete;   记住     优先考虑使用 deleted function 而非 private undefined    任何函数都能被删除（deleted），包括非成员函数和 template 实例化函数   item 12: 把重写函数声明为“override”   因为 overriding (重写)听起来有点像 overloading (重载)，但是他们完全没有关系，让我们来弄清楚，重写虚函数是为了通过基类的接口来调用派生类的函数。 classBase { public: virtual void doWork(); // base class virtual function 	… }; classDerived: public Base { public: virtual void doWork(); // overrides Base::doWork 	… // (&#34;virtual&#34; is optional  }; // here)  std::unique_ptr&lt;Base&gt; upb = // create base class pointer 	std::make_unique&lt;Derived&gt;(); // to derived class object;  // see Item 21 for info on  … // std::make_unique  upb-&gt;doWork(); // call doWork through base  // class ptr; derived class  // function is invoked    为了能够成功重写，必须要符合一些要求：    基类函数必须是 virtual 的。    基类函数和派生类函数的名字必须完全一样（除了析构函数）    基类函数和派生类函数的参数类型必须完全一样。    基类函数和派生类函数的 const 属性必须完全一样。    类函数和派生类函数的返回值类型以及异常规格（exception specification）必须是可兼容的    这些限制是 C&#43;&#43;98 要求的，C&#43;&#43;11 还增加了一条:    函数的引用限定符必须完全一样    “成员函数引用限定符”是 C&#43;&#43;11 中不太被知道的特性，所以即使你从来没有听过，也不需要吃惊。 它们的出现是为了限制成员函数只能被左值或右值中的一个使用。使用它们时，不需要一定是 virtual 成员函数： classWidget { public: void doWork() &amp;; // this version of doWork applies  // only when *this is an lvalue 	void doWork() &amp;&amp;; // this version of doWork applies  }; // only when *this is an rvalue  Widget makeWidget(); // factory function (returns rvalue)  Widget w; // normal object (an lvalue)  w."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Learning Hardy</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/archives/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Learning Hardy</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/archives/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; Ep04:Moving to Modern C&#43;&#43;(2)</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-12-26 </span>
        <div class="post-category">
            <a href="/categories/modern/"> Modern </a>
            <a href="/categories/c&#43;&#43;/"> C&#43;&#43; </a>
            </div>
        
      </div>
    </header>

    
    <div class="post-content">
      
<h1 id="headline-1">
item 11: 优先考虑使用 deleted function 而非 private undefined
</h1>
<p>
在 C++ 98 中禁止拷贝和赋值实现如下：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">charT</span>, <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">traits</span> <span style="color:#f92672">=</span> char_traits<span style="color:#f92672">&lt;</span>charT<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">basic_ios</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> ios_base {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#960050;background-color:#1e0010">…</span>
	  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	  basic_ios(<span style="color:#66d9ef">const</span> basic_ios<span style="color:#f92672">&amp;</span> ); <span style="color:#75715e">// not defined
</span><span style="color:#75715e"></span>	  basic_ios<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> basic_ios<span style="color:#f92672">&amp;</span>); <span style="color:#75715e">// not defined
</span><span style="color:#75715e"></span>  };
</code></pre></div>
</div>
<p>
In C++11,可使用 <strong>= delete</strong>
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">charT</span>, <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">traits</span> <span style="color:#f92672">=</span> char_traits<span style="color:#f92672">&lt;</span>charT<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">basic_ios</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> ios_base {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#960050;background-color:#1e0010">…</span>
	  basic_ios(<span style="color:#66d9ef">const</span> basic_ios<span style="color:#f92672">&amp;</span> ) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
	  basic_ios<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> basic_ios<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
	  <span style="color:#960050;background-color:#1e0010">…</span>
  };
</code></pre></div>
</div>
<!-- more -->
<p>
delete 还可以删除实例化模板
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">void</span> processPointer(T<span style="color:#f92672">*</span> ptr);

  <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
  <span style="color:#66d9ef">void</span> processPointer<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
  <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
  <span style="color:#66d9ef">void</span> processPointer<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</code></pre></div>
</div>
<h2 id="headline-2">
记住
</h2>
<ul>
<li>
<p>
优先考虑使用 deleted function 而非 private undefined
</p>
</li>
<li>
<p>
任何函数都能被删除（deleted），包括非成员函数和 template 实例化函数
</p>
</li>
</ul>
<h1 id="headline-3">
item 12: 把重写函数声明为“override”
</h1>
<p>
因为 <strong>overriding</strong> (重写)听起来有点像 <strong>overloading</strong> (重载)，但是他们完全没有关系，让我们来弄清楚，重写虚函数是为了通过基类的接口来调用派生类的函数。
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">Base</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> doWork(); <span style="color:#75715e">// base class virtual function
</span><span style="color:#75715e"></span>	  <span style="color:#960050;background-color:#1e0010">…</span>
  };
  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> doWork(); <span style="color:#75715e">// overrides Base::doWork
</span><span style="color:#75715e"></span>	  <span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// (&#34;virtual&#34; is optional
</span><span style="color:#75715e"></span>  }; <span style="color:#75715e">// here)
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>Base<span style="color:#f92672">&gt;</span> upb <span style="color:#f92672">=</span> <span style="color:#75715e">// create base class pointer
</span><span style="color:#75715e"></span>	  std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>Derived<span style="color:#f92672">&gt;</span>(); <span style="color:#75715e">// to derived class object;
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// see Item 21 for info on
</span><span style="color:#75715e"></span>  <span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// std::make_unique
</span><span style="color:#75715e"></span>  upb<span style="color:#f92672">-&gt;</span>doWork(); <span style="color:#75715e">// call doWork through base
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// class ptr; derived class
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// function is invoked
</span></code></pre></div>
</div>
<p>
为了能够成功重写，必须要符合一些要求：
</p>
<ul>
<li>
<p>
基类函数必须是 virtual 的。
</p>
</li>
<li>
<p>
基类函数和派生类函数的名字必须完全一样（除了析构函数）
</p>
</li>
<li>
<p>
基类函数和派生类函数的参数类型必须完全一样。
</p>
</li>
<li>
<p>
基类函数和派生类函数的 const 属性必须完全一样。
</p>
</li>
<li>
<p>
类函数和派生类函数的返回值类型以及异常规格（exception specification）必须是可兼容的
</p>
</li>
</ul>
<p>
这些限制是 C++98 要求的，C++11 还增加了一条:
</p>
<ul>
<li>
<p>
函数的引用限定符必须完全一样
</p>
</li>
</ul>
<p>
“成员函数引用限定符”是 C++11 中不太被知道的特性，所以即使你从来没有听过，也不需要吃惊。
它们的出现是为了限制成员函数只能被左值或右值中的一个使用。使用它们时，不需要一定是 virtual 成员函数：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">Widget</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	  <span style="color:#66d9ef">void</span> doWork() <span style="color:#f92672">&amp;</span>; <span style="color:#75715e">// this version of doWork applies
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// only when *this is an lvalue
</span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doWork</span>() <span style="color:#f92672">&amp;&amp;</span>; <span style="color:#75715e">// this version of doWork applies
</span><span style="color:#75715e"></span>  }; <span style="color:#75715e">// only when *this is an rvalue
</span><span style="color:#75715e"></span>
  Widget <span style="color:#a6e22e">makeWidget</span>(); <span style="color:#75715e">// factory function (returns rvalue)
</span><span style="color:#75715e"></span>  Widget w; <span style="color:#75715e">// normal object (an lvalue)
</span><span style="color:#75715e"></span>  w.doWork(); <span style="color:#75715e">// calls Widget::doWork for lvalues
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// (i.e., Widget::doWork &amp;)
</span><span style="color:#75715e"></span>  makeWidget().doWork(); <span style="color:#75715e">// calls Widget::doWork for rvalues
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// (i.e., Widget::doWork &amp;&amp;)
</span></code></pre></div>
</div>
<p>
写需要这么多的的要求，就意味着一个小的差错就会有很大影响。举个例子，下面的代码完全没有问题，并且乍一看也很合理，
但是它们没有包含虚函数重写
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">Base</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> mf1() <span style="color:#66d9ef">const</span>;
	  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf2</span>(<span style="color:#66d9ef">int</span> x);
	  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf3</span>() <span style="color:#f92672">&amp;</span>;
	  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf4</span>() <span style="color:#66d9ef">const</span>;
  };
  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> mf1();
	  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf2</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> x);
	  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf3</span>() <span style="color:#f92672">&amp;&amp;</span>;
	  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf4</span>() <span style="color:#66d9ef">const</span>;
  };
</code></pre></div>
</div>
<ul>
<li>
<p>
mf1 在基类中声明为 const，但是在派生类中却不是
</p>
</li>
<li>
<p>
mf2 在基类中的参数类型是 int，但是在派生类中的参数类型是 unsigned
</p>
</li>
<li>
<p>
mf3 在基类中是左值限定的，但是在派生类中是右值限定的
</p>
</li>
<li>
<p>
mf4 在基类中没声明为 virtual
</p>
</li>
</ul>
<p>
在派生类中，声明出正确的重写函数很重要，但是它们总是很容易出错，
所以 C++11 给了你一个方法来明确一个派生类函数需要重写一个基类函数，这个方法就是把函数声明为 <strong>override</strong> 的
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> mf1() <span style="color:#66d9ef">override</span>;
	  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf2</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> x) <span style="color:#66d9ef">override</span>;
	  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf3</span>() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">override</span>;
	  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf4</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">override</span>;
  };
</code></pre></div>
</div>
<p>
把所有的派生类中的重写函数都声明为 override，这个准则不仅能让编译器告诉你什么地方声明了 override 却没有重写任何东西。
而且当你考虑改变基类中虚函数的签名，它（这个准则）还能帮助你评估出影响大不大。如果派生类所有的地方都使用了 override，
你只需要改变函数签名，然后再编译一次你的系统，看看你造成了多大的损害（也就是，各个派生类中有多少函数不能编译），
然后再决定这些问题是否值得你去改变函数签名。
</p>
<p>
C++11 介绍了两个和上下文相关的关键字(<strong>contextual keywords</strong>)，override 和 final。
这两个关键字的特点是，只在特定的上下文中它们是保留的。
比如 override 的情况，只有当它出现在成员函数声明的最后时，它才是保留的。
这意味着如果你有历史遗留的代码，代码中已经使用了 override 作为 name，你不需要因为你使用了 C++11 而改变它：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">Warning</span> { <span style="color:#75715e">// potential legacy class from C++98
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#960050;background-color:#1e0010">…</span>
	  <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">override</span>(); <span style="color:#75715e">// legal in both C++98 and C++11
</span><span style="color:#75715e"></span>	  <span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// (with the same meaning)
</span><span style="color:#75715e"></span>  };
</code></pre></div>
</div>
<p>
需要引用限定功能的成员函数不常见，但是它是存在的。
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">Widget</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#66d9ef">using</span> DataType <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>; <span style="color:#75715e">// see Item 9 for
</span><span style="color:#75715e"></span>	  <span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// info on &#34;using&#34;
</span><span style="color:#75715e"></span>	  DataType<span style="color:#f92672">&amp;</span> data() { <span style="color:#66d9ef">return</span> values; }
	  <span style="color:#960050;background-color:#1e0010">…</span>
	  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	  DataType values;
  };

  Widget w;
  <span style="color:#960050;background-color:#1e0010">…</span>
  <span style="color:#66d9ef">auto</span> vals1 <span style="color:#f92672">=</span> w.data(); <span style="color:#75715e">// copy w.values into vals1
</span><span style="color:#75715e"></span>
  Widget <span style="color:#a6e22e">makeWidget</span>();
  <span style="color:#66d9ef">auto</span> vals2 <span style="color:#f92672">=</span> makeWidget().data(); <span style="color:#75715e">// copy values inside the
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Widget into vals2
</span></code></pre></div>
</div>
<p>
从 makeWidget 返回的临时对象（一个左值，），拷贝它的 std::vector 浪费时间，我们最好的做法是 move 它，
但是因为 data 返回一个左值引用，所以 C++的规则要求编译器生成拷贝的代码。
</p>
<p>
我们需要一个方法来明确一点，那就是当 data 被一个右值 Widget 调用时，结果也应该是一个右值。
使用引用限定符来重载 data 的左值和右值版本让之成为可能：
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">Widget</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	  <span style="color:#66d9ef">using</span> DataType <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>;
	  
	  DataType<span style="color:#f92672">&amp;</span> data() <span style="color:#f92672">&amp;</span> <span style="color:#75715e">// for lvalue Widgets,
</span><span style="color:#75715e"></span>		  { <span style="color:#66d9ef">return</span> values; } <span style="color:#75715e">// return lvalue
</span><span style="color:#75715e"></span>	  DataType data() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#75715e">// for rvalue Widgets,
</span><span style="color:#75715e"></span>		  { <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>move(values); } <span style="color:#75715e">// return rvalue
</span><span style="color:#75715e"></span>	  
	  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	  DataType values;
  };
</code></pre></div>
</div>
<h2 id="headline-4">
记住
</h2>
<ul>
<li>
<p>
把重写函数声明为 override 的
</p>
</li>
<li>
<p>
成员函数引用限定符能区别对待左值和右值对象（*this）
</p>
</li>
</ul>
<h1 id="headline-5">
item 13: 优先考虑 const_iterators 而非 iterators
</h1>
<p>
const_iterators 在 C++11 比 98 好用多了，但 C++11 只添加了 non-member 版本的 begin 和 end 函数，
而没有添加相应的 cbegin，cend，rbegin，rend，crbegin，crend。C++14 更正了这个问题。C++ 11 自己实现
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010"> </span><span style="color:#a6e22e">C</span><span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">auto</span> cbegin(<span style="color:#66d9ef">const</span> C<span style="color:#f92672">&amp;</span> container)<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">decltype</span>(std<span style="color:#f92672">::</span>begin(container))
  {
		  <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>begin(container); <span style="color:#75715e">// see explanation below
</span><span style="color:#75715e"></span>  }
</code></pre></div>
</div>
<p>
看到 non-member 版本的 cbegin 没有调用 member 版本的 cbegin，你觉得很奇怪是吧？我也觉得奇怪，但是跟着代码看下来。
cbegin 模板接受任何类型的参数来表示一个“类容器”（C），并且它通过它的 reference-to-const 形参（container）来使用实参。
如果 C 是一个普通的容器类型（比如，一个 std::vector），container 将成为一个指向 const 容器的引用（也就是，const std::vector&lt;int&gt;&amp;）。
用 const 容器调用 non-member 版本的 begin 函数（由 C++11 提供）就能产生一个 const_iterator，
并且这个 iterator 就是这个模板的返回值。用这样的方式来实现的优点是，对于那些提供了 begin 成员函数，但是没有提供 cbegin 成员函数的容器，
能更好地工作（在 C++11 的 non-member 版本的 begin 中，会调用这个容器的 begin 成员函数）。
因此，你能对只提供 begin 成员函数的容器，使用这个 non-member 版本的 cbegin。
</p>
<p>
如果 C 是一个 built-in 数组类型，这个模板也能工作。在这种情况下，container 成为一个指向 const 数组的引用。C++11 在 non-member 版本的 begin 中，
为数组提供了一个特殊的版本，这个版本的 begin 返回一个指向数组中第一个元素的指针。一个 const 数组的元素是 const 的，所以 non-member 版本的 begin 为
const 数组返回一个 point-to-const 的指针，并且事实上，一个 point-to-const 的指针对于数组来说就是一个 const_iterator。
（为了深入了解一个模板怎么为 built-in 数组特殊化，请看 Item 1 中，以指向数组的引用为参数的 template 类型推导的讨论）
</p>
<h2 id="headline-6">
记住
</h2>
<ul>
<li>
<p>
优先考虑 const_iterators 而非 iterators
</p>
</li>
<li>
<p>
在最大限度的通用代码中，优先考虑 begin，end，rbegin 等非成员版本的成员函数。
</p>
</li>
</ul>
<h1 id="headline-7">
item 14: 如果函数不会抛出异常就把它们声明为 noexcept
</h1>
<p>
在设计接口的时候，一个函数是不是应该这么声明（noexcept）是一个需要考虑的问题。函数的异常抛出行为是客户最感兴趣的部分。
调用者能查询一个函数的 noexcept 状态，并且这个查询的结果能影响异常安全（exception safety）或着调用代码的性能。
因此，一个函数是否是 noexcept 就和一个成员函数是否是 cosnt 同样重要。当你知道一个函数不会抛出异常的时候却不声明它为 noexcept，
就属于一个不好的接口设计。
</p>
<p>
但是，这里还有一个额外的动机让我们把 noexcept 应用到不会产生异常的函数上：它允许编译器产生更好的目标代码。
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> x) <span style="color:#66d9ef">throw</span>(); <span style="color:#75715e">// no exceptions from f: C++98 style
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> x) <span style="color:#66d9ef">noexcept</span>; <span style="color:#75715e">// no exceptions from f: C++11 style
</span></code></pre></div>
</div>
<p>
如果，运行时期，一个异常逃离了 f，这违反了 f 的异常规范。在 C++98 的异常规范下，f 的调用者的调用栈被解开了，然后经过一些不相关的动作，程序终止执行。
在 C++11 的异常规范下，运行期行为稍微有些不同：调用栈只有在程序终止前才有可能被解开。
</p>
<p>
解开调用栈的时机，以及解开的可能性的不同，对于代码的产生有很大的影响。在一个 noexcept 函数中，如果一个异常能传到函数外面去，
优化器不需要保持运行期栈为解开的状态，也不需要确保 noexcept 函数中的对象销毁的顺序和构造的顺序相反（因为 noexcept 是不应该抛出异常的）。
</p>
<p>
我们值得去注意一些库的接口设计区分了宽接口（ <strong>wide contract</strong> ）和窄接口（ <strong>narrow contract</strong> ）。
一个带宽接口的函数没有前提条件。这样的函数被调用时不需要注意程序的状态，它在传入的参数方面没有限制。
带宽接口的函数永远不会展现未定义行为。
</p>
<p>
不带宽接口条件的函数就是窄接口函数。对这些函数来说，如果传入的参数违反了前提条件，结果将是未定义的。
</p>
<p>
如果你在写一个宽接口的函数，并且你知道你不会抛出一个异常，那就遵循本 Item 的建议，把它声明为 noexcept。对于那些窄接口的函数，
情况将变得很棘手。举个例子，假设你正在写一个函数 f，这个函数接受一个 std::string 参数，并且它假设 f 的实现永远不会产生一个异常。
这个假设建议把 f 声明为 noexcept。
</p>
<p>
现在假设 f 有一个前提条件：std::string 参数的数据长度不会超过 32 个字节。如果用一个超过 32 字节的 std::string 来调用 f，f 的行为将是未定义的，
因为一个不符合前提条件的参数会导致未定义行为。f 没有义务去检查前提条件，因为函数假设它们的前提条件是被满足的（调用者有责任确保这些假设是有效的）。
由于前提条件的存在，把 f 声明为 noexcept 看起来是合理的。
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> s) <span style="color:#66d9ef">noexcept</span>; <span style="color:#75715e">// precondition:
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// s.length() &lt;= 32
</span></code></pre></div>
</div>
<p>
但是假设 f 的实现选择检查前提条件是否被违反了。检查本不是必须的，但是它也不是被禁止的，并且检查一下前提条件是有用的（比如，在进行系统测试的时候）。
调试时，捕捉一个抛出的异常总是比尝试找出未定义行为的原因要简单很多。但是要怎么报道出前提条件被违反了呢？
只有报道了才能让测试工具或客户端的错误处理机制来捕捉到它。一个直接的方法就是抛出一个“前提条件被违反”的异常，但是如果 f 被声明为 noexcept，
那么这个方法就不可行了，抛出一个异常就会导致程序终止。因此，区分宽接口和窄接口的库设计者通常只为宽接口函数提供 noexcept 声明。
</p>
<p>
编译器通常不能帮助识别函数实现与异常规范之间的不一致性。下段代码是完全合法的
</p>
<div class="src src-c++">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setup</span>(); <span style="color:#75715e">// functions defined elsewhere
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cleanup</span>();
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doWork</span>() <span style="color:#66d9ef">noexcept</span>
  {
	  setup(); <span style="color:#75715e">// set up work to be done
</span><span style="color:#75715e"></span>	  <span style="color:#960050;background-color:#1e0010">…</span> <span style="color:#75715e">// do the actual work
</span><span style="color:#75715e"></span>		  cleanup(); <span style="color:#75715e">// perform cleanup actions
</span><span style="color:#75715e"></span>  }
</code></pre></div>
</div>
<p>
在这里，尽管 doWork 调用了 non-noexcept 函数（setup 和 cleanup），doWork 还是被声明为 noexcept。这看起来很矛盾，
但是有可能 setup 和 cleanup 在说明文档中说了它们永远不会抛出异常。就算它们没有在说明文档中说明，
我们 还是有多理由来解释他们的声明式为什么是 non-noexcept。举个例子，它们可能是用 C 写的。（
也可能是从 C 标准库移动到 std 命名空间但缺少异常规范的函数，比如，std::strlen 没有声明为 noexcept）或者它们可能是 C++98 标准库的一部分，
没有使用 C++98 的异常规范，并且到目前为止还没有被修改成 C++11 的版本。
</p>
<p>
因为这里有很多合适的理由来解释为什么 noexcept 函数可以调用缺乏 noexcept 保证的函数，所以 C++允许这样的代码，并且编译器通常不会对此发出警告。
</p>
<h2 id="headline-8">
记住
</h2>
<ul>
<li>
<p>
noexcept 是函数接口的一部分，并且调用者可能会依赖这个接口
</p>
</li>
<li>
<p>
比起 non-noexcept 函数，noexcept 函数可以更好地被优化
</p>
</li>
<li>
<p>
noexcept 对于 move 操作，swap，内存释放函数和析构函数是特别有价值的
</p>
</li>
<li>
<p>
大部分函数是异常中立的而不是 noexcept
</p>
</li>
</ul>
<h1 id="headline-9">
参考
</h1>
<p>
effective-modern-c++
</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/c&#43;&#43;-ep05moving-to-modern-c&#43;&#43;3/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">C&#43;&#43; Ep05:Moving to Modern C&#43;&#43;(3)</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/c&#43;&#43;-ep03moving-to-modern-c&#43;&#43;1/">
            <span class="next-text nav-default">C&#43;&#43; Ep03:Moving to Modern C&#43;&#43;(1)</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://hardy5012.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
     - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author"></span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
