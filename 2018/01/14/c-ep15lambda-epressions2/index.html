<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; Ep15:Lambda Epressions(2) - Leaning Hardy</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Hardy Li" /><meta name="description" content="Item 33:对需要 std::forward 的 auto&amp;amp;&amp;amp;参数使用 decltype 泛型 lambda(generic lambda)是 C&#43;&#43;14 最令人兴奋的特性之一——lambda 可以在参数说明中使用 au" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.57.0 with even 4.0.0" />


<link rel="canonical" href="https://hardy5012.github.io/2018/01/14/c-ep15lambda-epressions2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.b1b2fc82.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43; Ep15:Lambda Epressions(2)" />
<meta property="og:description" content="Item 33:对需要 std::forward 的 auto&amp;&amp;参数使用 decltype 泛型 lambda(generic lambda)是 C&#43;&#43;14 最令人兴奋的特性之一——lambda 可以在参数说明中使用 au" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hardy5012.github.io/2018/01/14/c-ep15lambda-epressions2/" />
<meta property="article:published_time" content="2018-01-14T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-01-14T00:00:00+00:00" />
<meta itemprop="name" content="C&#43;&#43; Ep15:Lambda Epressions(2)">
<meta itemprop="description" content="Item 33:对需要 std::forward 的 auto&amp;&amp;参数使用 decltype 泛型 lambda(generic lambda)是 C&#43;&#43;14 最令人兴奋的特性之一——lambda 可以在参数说明中使用 au">


<meta itemprop="datePublished" content="2018-01-14T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2018-01-14T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="5573">



<meta itemprop="keywords" content="C&#43;&#43;," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; Ep15:Lambda Epressions(2)"/>
<meta name="twitter:description" content="Item 33:对需要 std::forward 的 auto&amp;&amp;参数使用 decltype 泛型 lambda(generic lambda)是 C&#43;&#43;14 最令人兴奋的特性之一——lambda 可以在参数说明中使用 au"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Learning</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/post/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Learning</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/post/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; Ep15:Lambda Epressions(2)</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-01-14 </span>
        <div class="post-category">
            <a href="/categories/modern/"> Modern </a>
            <a href="/categories/c&#43;&#43;/"> C&#43;&#43; </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#headline-1">Item 33:对需要 std::forward 的 auto&amp;&amp;参数使用 decltype</a>
<ul>
<li><a href="#headline-2">记住</a>
</li>
</ul>
</li>
<li><a href="#headline-3">Item 34:优先考虑使用 lambda 而不是 std::bind</a>
<ul>
<li><a href="#headline-4">记住</a>
</li>
</ul>
</li>
<li><a href="#headline-5">参考</a>
</li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      
<h1 id="headline-1">
Item 33:对需要 std::forward 的 auto&amp;&amp;参数使用 decltype
</h1>
<p>
泛型 lambda(generic lambda)是 C++14 最令人兴奋的特性之一——lambda 可以在参数说明中使用 auto。这个特性的实现很直截了当：
闭包类中的  <strong>operator()</strong> 函数是一个模板。例如，给定这个 lambda，
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
闭包类的函数调用操作符看起来是这样的：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span><span class="err"> </span><span class="nc">SomeCompilerGeneratedClassName</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
	  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// see Item 3 for
</span><span class="c1"></span>	  <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="c1">// auto return type
</span><span class="c1"></span>		  <span class="p">{</span> <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="p">}</span>
	  <span class="err">…</span> <span class="c1">// other closure class
</span><span class="c1"></span>  <span class="p">};</span> <span class="c1">// functionality
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<!-- more -->
<p>
在这个例子中，lambda 对 x 做的唯一的一件事就是把它转发给 normalized。如果 normalized 区别对待左值和右值，这个 lambda 这样写是不合适的，
因为即使传递给 lambda 的实参是个右值，lambda 总是传一个左值（形参 x）给 normalized。
</p>
<p>
写这个 lambda 的正确方式是把 x 完美转发给 normalized，这样做需要在代码中修改两个地方。第一，x 要改成通用引用（看条款 24），
第二，借助 std::forward（看条款 25）把 x 转发到 normalized。在概念上，修改成这样：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span> <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;???&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span> <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
但是，在概念和实现之间，有一个问题，就是你传递给 std::forward 的参数是什么类型，这决定了我上面写的???的地方会变成怎样。
</p>
<p>
一般来说，当你使用完美转发时，你是在一个接受类型形参 T 的模板函数中，所以你只是写 std::forward&lt;T&gt;。而在泛型模板中，没有你可以拿到的类型参数 T。
在 lambda 生成的闭包内，模板化 operator()函数有一个 T，但是在 lambda 中无法指定它，所以它对你没有任何帮助。
</p>
<p>
条款 28 解释过如果把一个左值传递给通用引用，通用引用的类型会变为左值引用；如果把一个右值传递给通用引用，通用引用会变为一个右值引用。
那意味着在我们的 lambda 中，我们可以通过检查 x 的类型来判断传递进来的实参是左值还是右值， <strong>decltype</strong> 就可以让我们这样做。
如果传递给 lambda 的是个左值，decltype(x)将会产生一个左值引用；如果传递给 lambda 的是个右值，decltype(x)将会产生一个右值引用。
</p>
<p>
条款 28 也解释了当使用 std::forward 时，有一个规则：传给它的类型参数是个左值引用时，表明返回的是个左值，传递给它的类型参数是个非引用类型时，
表明返回的是个右值。在我们的 lambda 中，如果 x 绑定的是一个左值引用，decltype(x)将产生一个左值引用，这符合规则。
不过，如果 x 绑定的是个右值，decltype(x)将会产生一个右值引用，而不是常规的非引用。
（要注意的是，条款 28 中传递给 std::forward 的类型参数是 T，而在 lambda 中无法使用 T，也无法使用 auto，
所以只能将 decltype(x)作为 std::forward 的类型参数。）
</p>
<p>
但看回在条款 28 中，std::forward 的 C++14 实现：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// in namespace
</span><span class="c1"></span>  <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="c1">// std
</span><span class="c1"></span>  <span class="p">{</span>
	  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
如果一个用户想要完美转发一个 Widegt 类型的右值，它正常地用 Widget 类型（即非引用类型）实例化 std::forward，然后 std::forward 产生这个函数：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="c1">// instantiation of
</span><span class="c1"></span>  <span class="p">{</span> <span class="c1">// std::forward when
</span><span class="c1"></span>	  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span> <span class="c1">// T is Widget
</span><span class="c1"></span>  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
不过，请思考如果用户代码想要完美转发一个 Widget 类型的右值，但是这次它没有服从规则将 T 指定为非引用类型，而是将 T 指定为右值引用，
这会发生什么？那是，思考把 T 替换成 Widget&amp;&amp;将会发生什么。在 std::forward 实例化、应用了 <strong>std::remove_reference_t</strong> 之后，
引用折叠（再次看条款 28，看懂！）之前，std::forward 看起来是这样的：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="c1">// instantiation of
</span><span class="c1"></span>  <span class="p">{</span> <span class="c1">// std::forward when
</span><span class="c1"></span>	  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span> <span class="c1">// T is Widget&amp;&amp;
</span><span class="c1"></span>  <span class="p">}</span> <span class="c1">// (before reference-
</span><span class="c1"></span>  <span class="c1">// collapsing)
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
如果你用这个实例化和把 T 设置为 Widget 的 std::forward 那个实例化进行比较，你会发现它们是相同的。那意味着用一个右值引用实例化 std::forward，
和用一个非引用类型实例化 std::forward 产生的结果相同。
</p>
<p>
那是个很棒的消息，因为当一个右值实参传递给 lambda 形参 x 时，decltype(x)会产生一个右值引用。我们在上面已经确认了把一个左值传给 lambda 时，
decltype(x)会产生一个可以传给 std::forward 的常规类型，而现在我们认识到对于右值，把 decltype(x)产生的类型传递给 std::forward 的类型参数是不传统的，
不过，它产生的结果与传统类型产生的结果相同。所以无论是左值还是右值，把 decltype(x)传递给 std::forward 都能得到我们想要的结果，
因此我们的完美转发 lambda 可以这样写：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span>
	  <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>
  <span class="p">{</span>
	  <span class="k">return</span>
	  <span class="n">func</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">param</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">)));</span>
  <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
在这份代码加上 6 个点，就可以让我们的完美转发 lambda 接受多个参数了，因为 C++14 的 lambda 的参数是可变的：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span>
	  <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span>
  <span class="p">{</span>
	  <span class="k">return</span>
	  <span class="n">func</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...));</span>
  <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<h2 id="headline-2">
记住
</h2>
<ul>
<li>
<p>
对需要 std::forward 的 auto&amp;&amp;参数使用 decltype（Use decltype on auto&amp;&amp; parameters to std::forward them.）。
</p>
</li>
</ul>
<h1 id="headline-3">
Item 34:优先考虑使用 lambda 而不是 std::bind
</h1>
<p>
C++11 的 std::bind 是 C++98 的 std::bind1st 和 std::bind2nd 的继承人，但是，通俗的说，std::bind 在 2005 年的时候已经是标准库的一部分了，
那个时候标准委员会采用了名为 TR1 的文档，里面就包含 std::bind 的说明。（在 TR1 中，bind 在不同的命名空间，所以它是 std::tr1::bind，
而不是 std::bind，接口和现在有点不同。）这个历史意味着一些开发者对 std::bind 已经有了十年的或者更多的开发经验了，如果你是他们中的一员，
你可能不愿意放弃这个工作得好好的工具。这是可以理解的，但是在如今的情况下，作出改变是好的，因为在 C++11，比起使用 std::bind，lambda 几乎总是更好的选择。
到了 C++14，lambda 在这种情况中不只是变强了，它还披上了装甲。
</p>
<p>
该条款假设你熟悉 std::bind，如果你不熟悉，那么在继续看下去之前，你要对它有基本的认识。这种的认识在某些情况下是值得的，因为你不会知道，在哪一个时间点，
看代码或者维护代码时遇到 std::bind。
</p>
<p>
就像条款 32 所说，我 std::bind 返回的函数对象称为绑定对象（bind object）。
</p>
<p>
比起 std::bind 更偏爱 lambda 的最主要原因是 lambda 的具有更好的可读性。举个例子，假设我们有个函数用来设置警报：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="c1">// typedef for a point in time (see Item 9 for syntax)
</span><span class="c1"></span>  <span class="k">using</span> <span class="n">Time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span><span class="p">;</span>
  <span class="c1">// see Item 10 for &#34;enum class&#34;
</span><span class="c1"></span>  <span class="k">enum</span> <span class="k">class</span><span class="err"> </span><span class="nc">Sound</span> <span class="p">{</span> <span class="n">Beep</span><span class="p">,</span> <span class="n">Siren</span><span class="p">,</span> <span class="n">Whistle</span> <span class="p">};</span>
  <span class="c1">// typedef for a length of time
</span><span class="c1"></span>  <span class="k">using</span> <span class="n">Duration</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">duration</span><span class="p">;</span>
  <span class="c1">// at time t, make sound s for duration d
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">setAlarm</span><span class="p">(</span><span class="n">Time</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sound</span> <span class="n">s</span><span class="p">,</span> <span class="n">Duration</span> <span class="n">d</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
进一步假设，在程序的某些地方，我们想要设置在一个小时之后发出警报，持续 30 秒。但是呢，警报的类型，依然是未决定的。
我们可以写一个修改了 setAlarm 接口的 lambda，从而只需要指定警报类型
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="c1">// setSoundL (&#34;L&#34; for &#34;lambda&#34;) is a function object allowing a
</span><span class="c1"></span>  <span class="c1">// sound to be specified for a 30-sec alarm to go off an hour
</span><span class="c1"></span>  <span class="c1">// after it&#39;s set
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">setSoundL</span> <span class="o">=</span>
	  <span class="p">[](</span><span class="n">Sound</span> <span class="n">s</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="c1">// make std::chrono components available w/o qualification
</span><span class="c1"></span>	  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="p">;</span>
	  <span class="n">setAlarm</span><span class="p">(</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="n">hours</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="c1">// alarm to go off
</span><span class="c1"></span>			   <span class="n">s</span><span class="p">,</span> <span class="c1">// in an hour for
</span><span class="c1"></span>			   <span class="n">seconds</span><span class="p">(</span><span class="mi">30</span><span class="p">));</span> <span class="c1">// 30 seconds
</span><span class="c1"></span>  <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
注意看 lambda 里的 setAlarm，这是一个正常的函数调用，就算只有一点 lambda 经验的读者都可以看出传递给 lambda 的参数会作为 setAlarm 的一个实参
</p>
<p>
我们可以使用 C++14 对于秒(s)，毫秒(ms)，时(h)等标准后缀来简化代码，那是基于 C++11 的支持而照字面意思定义的。
这些后缀在 <strong>std::literals</strong> 命名空间里实现，所以上面的代码可以写成这样：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">setSoundL</span> <span class="o">=</span>
	  <span class="p">[](</span><span class="n">Sound</span> <span class="n">s</span><span class="p">)</span>
  <span class="p">{</span>
	  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="p">;</span>
	  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span> <span class="c1">// for C++14 suffixes
</span><span class="c1"></span>	  <span class="n">setAlarm</span><span class="p">(</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="n">h</span><span class="p">,</span> <span class="c1">// C++14, but
</span><span class="c1"></span>			   <span class="n">s</span><span class="p">,</span> <span class="c1">// same meaning
</span><span class="c1"></span>			   <span class="mi">30</span><span class="n">s</span><span class="p">);</span> <span class="c1">// as above
</span><span class="c1"></span>  <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
我们第一次尝试写出对应的 std::bind 调用，代码在下面。我们在注释中说明它有个错误，但是正确的代码复杂得多，而这个简化的版本可以让我们看到重要的问题：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="p">;</span> <span class="c1">// as above
</span><span class="c1"></span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span>
  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="p">;</span> <span class="c1">// needed for use of &#34;_1&#34;
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">setSoundB</span> <span class="o">=</span> <span class="c1">// &#34;B&#34; for &#34;bind&#34;
</span><span class="c1"></span>	  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">setAlarm</span><span class="p">,</span>
				<span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="n">h</span><span class="p">,</span> <span class="c1">// incorrect! see below
</span><span class="c1"></span>				<span class="n">_1</span><span class="p">,</span>
				<span class="mi">30</span><span class="n">s</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这份代码的读者简单地知道在 setSoundB 里，std::bind 会用指定时间点和持续时间来调用 setAlarm。对于缺少经验的读者，占位符“_1”简直是个魔术，
为了理解 setSoundB 的第一个实参会传递给 setAlarm 的第二个参数，读者需要聪明地把 std::bind 参数列表上占位符的数字和它的位置进行映射。
这个实参的类型在 std::bind 没有说明，所以读者还需要去咨询 setAlarm 的声明，来决定传递给 setSoundB 的参数类型。
</p>
<p>
但是，如我所说，这代码不完全正确。在 lambda 中，很明显表达式“ <strong>steady_clock::now() + 1h</strong> ”是 setAlarm 的一个实参，当 setAlarm 调用时，
表达式会被求值。那是行得通的：我们想要在调用了 setAlarm 后的一个小时触发警报。
<span style="text-decoration: underline;">但在 std::bind 的调用中，“steady_clock::now() + 1h”作为实参传递给 std::bind，而不是 setAlarm，那意味着表达式在调用 std::bind 的时候已经被求值，那么表达式的结果时间会被存储在产生的绑定对象中</span> 。
最终，警报会在调用了 std::bind 后的一个小时触发，而不是调用 setAlarm 后的一个小时！
</p>
<p>
解决这个问题需要告知 std::bind 推迟表达式的求值，直到 setAlarm 被调用，而这种办法需要在原来的 std::bind 内嵌入一个新的 std::bind：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">setSoundB</span> <span class="o">=</span>
	  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">setAlarm</span><span class="p">,</span>
				<span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;&gt;</span><span class="p">(),</span> <span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">(),</span> <span class="mi">1</span><span class="n">h</span><span class="p">),</span>
				<span class="n">_1</span><span class="p">,</span>
				<span class="mi">30</span><span class="n">s</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
如果你熟悉来自 C++98 的 std::plus，你可能会对这份代码感到惊奇，因为在两个方括号之间没有指定类型，即代码含有 <strong>std::plus&lt;&gt;</strong> ，
而不是 std::plus&lt;type&gt;。在 C++14，标准操作符模板的模板类型参数可以被省略，所以这里提供类型给它。
C++11 没有提供这种特性，所以在 C++11 中对于 lambda 的 std::bind 等同物是这样的：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="p">;</span> <span class="c1">// as above
</span><span class="c1"></span>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">setSoundB</span> <span class="o">=</span>
	  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">setAlarm</span><span class="p">,</span>
				<span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span><span class="o">&gt;</span><span class="p">(),</span>
						  <span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">(),</span>
						  <span class="n">hours</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
				<span class="n">_1</span><span class="p">,</span>
				<span class="n">seconds</span><span class="p">(</span><span class="mi">30</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
如果，在现在这个时刻，lambda 的实现看起来没有吸引力的话，你可能需要去检查一下视力了。
</p>
<p>
当 setAlarm 被重载，会出现一个新的问题。假如有个重载接受第四个参数来指定警报的音量：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">enum</span> <span class="k">class</span><span class="err"> </span><span class="nc">Volume</span> <span class="p">{</span> <span class="n">Normal</span><span class="p">,</span> <span class="n">Loud</span><span class="p">,</span> <span class="n">LoudPlusPlus</span> <span class="p">};</span>
  <span class="kt">void</span> <span class="nf">setAlarm</span><span class="p">(</span><span class="n">Time</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sound</span> <span class="n">s</span><span class="p">,</span> <span class="n">Duration</span> <span class="n">d</span><span class="p">,</span> <span class="n">Volume</span> <span class="n">v</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
之前那个 lambda 还会工作得很好，因为重载决策会选择带有三个参数的 setAlarm 版本：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">setSoundL</span> <span class="o">=</span> <span class="c1">// same as before
</span><span class="c1"></span>	  <span class="p">[](</span><span class="n">Sound</span> <span class="n">s</span><span class="p">)</span>
  <span class="p">{</span>
	  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="p">;</span>
	  <span class="n">setAlarm</span><span class="p">(</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="n">h</span><span class="p">,</span> <span class="c1">// fine, calls
</span><span class="c1"></span>			   <span class="n">s</span><span class="p">,</span> <span class="c1">// 3-arg version
</span><span class="c1"></span>			   <span class="mi">30</span><span class="n">s</span><span class="p">);</span> <span class="c1">// of setAlarm
</span><span class="c1"></span>  <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
另一方面，std::bind 的调用，现在会编译失败：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">setSoundB</span> <span class="o">=</span> <span class="c1">// error! which
</span><span class="c1"></span>	  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">setAlarm</span><span class="p">,</span> <span class="c1">// setAlarm?
</span><span class="c1"></span>				<span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;&gt;</span><span class="p">(),</span>
						  <span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">(),</span>
						  <span class="mi">1</span><span class="n">h</span><span class="p">),</span>
				<span class="n">_1</span><span class="p">,</span>
				<span class="mi">30</span><span class="n">s</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
问题在于编译器没有办法决定哪个 setAlarm 应该被传递给 std::bind，它拥有的只是一个函数名，而这单独的函数名是有歧义的
</p>
<p>
为了让 std::bind 可以通过编译，setAlarm 必须转换为合适的函数指针类型
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">using</span> <span class="n">SetAlarm3ParamType</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">Time</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sound</span> <span class="n">s</span><span class="p">,</span> <span class="n">Duration</span> <span class="n">d</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">setSoundB</span> <span class="o">=</span> <span class="c1">// now
</span><span class="c1"></span>	  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">SetAlarm3ParamType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">setAlarm</span><span class="p">),</span> <span class="c1">// okay
</span><span class="c1"></span>				<span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;&gt;</span><span class="p">(),</span>
						  <span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">(),</span>
						  <span class="mi">1</span><span class="n">h</span><span class="p">),</span>
				<span class="n">_1</span><span class="p">,</span>
				<span class="mi">30</span><span class="n">s</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
但这又引出了 lambda 和 std::bind 的另一个不同之处。在 setSoundL 的函数调用操作符内（即，lambda 的闭包类的函数调用操作符），
是以普通函数调用的方式调用 setAlarm，这可以被编译器以通用的方式内联：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">setSoundL</span><span class="p">(</span><span class="n">Sound</span><span class="o">::</span><span class="n">Siren</span><span class="p">);</span> <span class="c1">// body of setAlarm may
</span><span class="c1"></span>  <span class="c1">// well be inlined here
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
不过，在 std::bind 的调用中，传递了一个指向 setAlarm 的函数指针，而那意味着在 setSoundB 的函数调用操作符内（即，绑定对象的函数调用操作符），
是以函数指针的方式调用 setAlarm，而那意味着通过 setSoundB 调用的 setAlarm，比通过 setSoundL 调用的 setAlarm 进行内联的可能性更低：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">setSoundB</span><span class="p">(</span><span class="n">Sound</span><span class="o">::</span><span class="n">Siren</span><span class="p">);</span> <span class="c1">// body of setAlarm is less
</span><span class="c1"></span>  <span class="c1">// likely to be inlined here
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
因此，使用 lambda 生成的代码可能会比使用 std::bind 的快。
</p>
<p>
setAlarm 那个例子只是简单地调用了一个函数，如果你想做一些更复杂的事情，使用 lambda 的好处会更加明显。
例如，思考这个 C++14 的 lambda，返回它的实参是否在最小值（lowVal）和最大值（highVal）之间，lowVal 和 highVal 都是局部变量：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">betweenL</span> <span class="o">=</span>
	  <span class="p">[</span><span class="n">lowVal</span><span class="p">,</span> <span class="n">highVal</span><span class="p">]</span>
	  <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="c1">// C++14
</span><span class="c1"></span>  <span class="p">{</span> <span class="k">return</span> <span class="n">lowVal</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">highVal</span><span class="p">;</span> <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
std::bind 也可以表达同样的东西，不过它为了保证工作正常运行而让代码变得晦涩：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="p">;</span> <span class="c1">// as above
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">betweenB</span> <span class="o">=</span>
	  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">logical_and</span><span class="o">&lt;&gt;</span><span class="p">(),</span> <span class="c1">// C++14
</span><span class="c1"></span>				<span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">less_equal</span><span class="o">&lt;&gt;</span><span class="p">(),</span> <span class="n">lowVal</span><span class="p">,</span> <span class="n">_1</span><span class="p">),</span>
				<span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">less_equal</span><span class="o">&lt;&gt;</span><span class="p">(),</span> <span class="n">_1</span><span class="p">,</span> <span class="n">highVal</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
在 C++11，你还必须指定要比较的类型，所以 std::bind 的调用看起来是这样的：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">betweenB</span> <span class="o">=</span> <span class="c1">// C++11 version
</span><span class="c1"></span>	  <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">logical_and</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(),</span>
				<span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">lowVal</span><span class="p">,</span> <span class="n">_1</span><span class="p">),</span>
				<span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">less_equal</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">_1</span><span class="p">,</span> <span class="n">highVal</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
当然，在 C++11 中，lambda 不能使用 auto 形参，所以它也必须指定类型：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">betweenL</span> <span class="o">=</span> <span class="c1">// C++11 version
</span><span class="c1"></span>	  <span class="p">[</span><span class="n">lowVal</span><span class="p">,</span> <span class="n">highVal</span><span class="p">]</span>
	  <span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
  <span class="p">{</span> <span class="k">return</span> <span class="n">lowVal</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">highVal</span><span class="p">;</span> <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
不管怎样，我希望我们能认同 lambda 的版本不仅代码更短，还具有更好的可读性和可维护性。
</p>
<p>
在早些时候，我提起过对于那些对 std::bind 没有经验的程序员，占位符（例如，_1，_2 等）跟是魔术一样。
不过，占位符的行为不是完全密封的。假设我们有一个用来精简拷贝 Widget 的函数，
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">enum</span> <span class="k">class</span><span class="err"> </span><span class="nc">CompLevel</span> <span class="p">{</span> <span class="n">Low</span><span class="p">,</span> <span class="n">Normal</span><span class="p">,</span> <span class="n">High</span> <span class="p">};</span> <span class="c1">// compression
</span><span class="c1"></span>  <span class="c1">// level
</span><span class="c1"></span>  <span class="n">Widget</span> <span class="nf">compress</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">,</span> <span class="c1">// make compressed
</span><span class="c1"></span>				  <span class="n">CompLevel</span> <span class="n">lev</span><span class="p">);</span> <span class="c1">// copy of w
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
然后我们想要创建一个函数对象，它允许我们指定 Widget w 的精简级别，这是用 std::bind 创建的函数对象：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">compressRateB</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">compress</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">_1</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
当我们把 w 传递给 std::bind 时，为了以后的 compress 调用，w 会被存储起来，它存储在对象 compressRateB 中，但它是如何存储的呢——通过值还是引用呢？
这是会导致不一样的结果，因为如果 w 在调用 std::bind 和调用 compressRateB 之间被修改，通过引用存储的 w 也会随之改变，而通过值存储就不会改变。
</p>
<p>
答案是通过值存储，你想知道答案的唯一办法就是知道 std::bind 是如何工作的；但在 std::bind 中没有任何迹象。
对比使用 lambda 方法，w 通过值捕获或通过引用捕获都是显式的：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">compressRateL</span> <span class="o">=</span> <span class="c1">// w is captured by
</span><span class="c1"></span>	  <span class="p">[</span><span class="n">w</span><span class="p">](</span><span class="n">CompLevel</span> <span class="n">lev</span><span class="p">)</span> <span class="c1">// value; lev is
</span><span class="c1"></span>  <span class="p">{</span> <span class="k">return</span> <span class="n">compress</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">lev</span><span class="p">);</span> <span class="p">};</span> <span class="c1">// passed by value
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
参数以何种方式传递也是显示的。在这里，很清楚地知道参数 lev 是以值传递的。因此：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">compressRateL</span><span class="p">(</span><span class="n">CompLevel</span><span class="o">::</span><span class="n">High</span><span class="p">);</span> <span class="c1">// arg is passed
</span><span class="c1"></span>  <span class="c1">// by value
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
但在绑定对象里，参数是以什么方式传递的呢？
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">compressRateB</span><span class="p">(</span><span class="n">CompLevel</span><span class="o">::</span><span class="n">High</span><span class="p">);</span> <span class="c1">// how is arg
</span><span class="c1"></span>  <span class="c1">// passed?
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
再次说明，想知答案的唯一办法是记住 std::bind 是怎样工作的。（答案是传递给绑定对象的所有参数都是通过引用的方式，因为绑定对象的函数调用操作符使用了完美转发。）
</p>
<p>
那么，对比 lambda，使用 std::bind 的代码可读性不足、表达能力不足，还可能效率低。在 C++14，没有理由使用 std::bind。
而在 C++11，std::bind 可以使用在受限的两个场合：
</p>
<ul>
<li>
<p>
移动捕获。C++11 的 lambda 没有提供移动捕获，但可以结合 std::bind 和 lambda 来效仿移动捕获。具体细节看条款 32，那里也解释了 C++11 效仿 C++14 的 lambda 提供的初始化捕获的情况。
</p>
</li>
<li>
<p>
多态函数对象。因为绑定对象的函数调用操作符会使用完美转发，它可以接受任何类型的实参（条款 30 讲述了完美转发的限制）。这在你想要绑定一个函数调用操作符模板时有用。例如，给定这个类：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span><span class="err"> </span><span class="nc">PolyWidget</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
<span class="err">…</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
</li>
</ul>
<p>
std::bind 可以绑定 polyWidget 对象：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">PolyWidget</span> <span class="n">pw</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">boundPW</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">pw</span><span class="p">,</span> <span class="n">_1</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
然后 boundPW 可以绑定任何类型的实参：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">boundPW</span><span class="p">(</span><span class="mi">1930</span><span class="p">);</span> <span class="c1">// pass int to
</span><span class="c1"></span>  <span class="c1">// PolyWidget::operator()
</span><span class="c1"></span>  <span class="n">boundPW</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span> <span class="c1">// pass nullptr to
</span><span class="c1"></span>  <span class="c1">// PolyWidget::operator()
</span><span class="c1"></span>  <span class="n">boundPW</span><span class="p">(</span><span class="s">&#34;Rosebud&#34;</span><span class="p">);</span> <span class="c1">// pass string literal to
</span><span class="c1"></span>  <span class="c1">// PolyWidget::operator()
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
这在 C++11 的 lambda 里无法做到，但是在 C++14，使用 auto 形参就很容易做到了：
</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">auto</span> <span class="n">boundPW</span> <span class="o">=</span> <span class="p">[</span><span class="n">pw</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="c1">// C++14
</span><span class="c1"></span>  <span class="p">{</span> <span class="n">pw</span><span class="p">(</span><span class="n">param</span><span class="p">);</span> <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
当然，这些都是边缘情况，而且这种边缘情况会转瞬即逝，因为支持 C++14 的编译器已经越来越普遍。
</p>
<p>
2005 年，bind 非官方地加入了 C++，比起它的前身有了很多的进步。而在 C++11，lambda 几乎要淘汰 std::bind，
而在 C++14，std::bind 已经没有需要使用的场合了。
</p>
<h2 id="headline-4">
记住
</h2>
<ul>
<li>
<p>
比起使用 std::bind，lambda 有更好的可读性，更强的表达能力，可能还有更高的效率。
</p>
</li>
<li>
<p>
在 C++11，只有在实现移动捕获或者绑定函数调用操作符模板时，std::bind 可能是有用的。
</p>
</li>
</ul>
<h1 id="headline-5">
参考
</h1>
<p>
原文：effective-modern-c++
翻译：<a href="http://blog.csdn.net/big_yellow_duck/article/category/635234">http://blog.csdn.net/big_yellow_duck/article/category/635234</a>
</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Hardy Li</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2018-01-14
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2018/01/15/c-ep16the-concurrency-api1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">C&#43;&#43; Ep16:The Concurrency API(1)</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2018/01/11/c-ep14lambda-epressions1/">
            <span class="next-text nav-default">C&#43;&#43; Ep14:Lambda Epressions(1)</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
      <a href="http://localhost:1313" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="http://localhost:1313" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://hardy5012.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Hardy Li</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      TeX: {equationNumbers: {autoNumber: "AMS"}},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
