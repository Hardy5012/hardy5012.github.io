<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Weekly on Learning Hardy</title>
    <link>http://example.org/categories/weekly/</link>
    <description>Recent content in Weekly on Learning Hardy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 07 Mar 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://example.org/categories/weekly/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C&#43;&#43; Ep23: constexpr if</title>
      <link>http://example.org/post/c&#43;&#43;-ep23-if-constexpt/</link>
      <pubDate>Wed, 07 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/c&#43;&#43;-ep23-if-constexpt/</guid>
      <description> 以 if constexpr 开始的语句被称为 constexpr if 语句，从 c++17 起支持。在 constexpr if 语句中，条件的值必须能语境地转换到 bool 类型的 *常量表达式*。其值为 true，则舍去 false 分支语句 （若存在），否则舍去 true 分支语句 。示例： #include&amp;lt;type_traits&amp;gt; #include&amp;lt;iostream&amp;gt; template&amp;lt;typename T&amp;gt; auto print_type_info(const T &amp;amp;t) { if constexpr(std::is_integral&amp;lt;T&amp;gt;::value){ return t + 1; } else if constexpr(std::is_floating_point&amp;lt;T&amp;gt;::value){ return t + 0.1; } else{ return t; } } int main() { std::cout &amp;lt;&amp;lt; print_type_info(5) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; std::cout &amp;lt;&amp;lt; print_type_info(4.3) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; std::cout &amp;lt;&amp;lt; print_type_info(&amp;#34;hello world&amp;#34;) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; }    在上面的例中，当传参 5 时。语句可看成： template&amp;lt;typename T&amp;gt; auto print_type_info(const T &amp;amp;t) { return t + 1; }    说明：    constexpr 整个条件语句都会执行，与普通的不同(如 &amp;amp;&amp;amp; 在前面为 false 时会中断)。    在被舍去语句中的 return 语句不参与函数返回类型推导    被舍去语句可以 odr 使用不定义的变量    若 constexpr if 语句出现于模板实体内，且若 条件 在实例化后不是值依赖的，则在实例化外围模板时不会实例化被舍去语句    在模板外，被舍去语句受到完整的检查。if constexpr 不是 #if 预处理指令的替代品   </description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep22: Fibonacci</title>
      <link>http://example.org/post/c&#43;&#43;-ep22-fibonacci/</link>
      <pubDate>Wed, 28 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/c&#43;&#43;-ep22-fibonacci/</guid>
      <description>Fibonacci(斐波那契数)的特点是每一个数都是前二个数的和.以下测试都使用第 45 个值。 递归版本  int fib(const int i) { if(i == 0) return 0; if(i == 1) return 1; return fib(i - 1) + fib(i - 2); }      文件大小：8.7K    时间：7.4S   模板版本  template&amp;lt;int I&amp;gt; struct Fib { static const int val = Fib&amp;lt;I-1&amp;gt;::val + Fib&amp;lt;I-2&amp;gt;::val; }; template&amp;lt;&amp;gt; struct Fib&amp;lt;0&amp;gt; { static const int val = 0; }; template&amp;lt;&amp;gt; struct Fib&amp;lt;1&amp;gt; { static const int val = 1; };      文件大小：8.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep21: variadic Templates</title>
      <link>http://example.org/post/c&#43;&#43;-ep21-variadic-templates/</link>
      <pubDate>Wed, 21 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/c&#43;&#43;-ep21-variadic-templates/</guid>
      <description>使用  之前   在使用可变参数模板之前，如果有几个参数，就需要对应的模块。 //一个参数  template&amp;lt;typename T1&amp;gt; //两个参数  template&amp;lt;typename T1, typename T2&amp;gt; //三个参数  template&amp;lt;typename T1, typename T2, typename T3&amp;gt; ....    无论是实现还是效率都非常差 可变参数版本（递归实现）   对于上面情况，使用可变参数模板实现： #include &amp;lt;sstream&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; template&amp;lt;typename T&amp;gt; std::string to_string_impl(const T&amp;amp; t) { std::stringstream ss; ss &amp;lt;&amp;lt; t; return ss.str(); } std::vector&amp;lt;std::string&amp;gt; to_string(){ return {}; } template&amp;lt;typename P1, typename ...Param&amp;gt; std::vector&amp;lt;std::string&amp;gt; to_string(const P1 &amp;amp;p1, const Param&amp;amp; .</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Ep20: Static Variable</title>
      <link>http://example.org/post/c&#43;&#43;-ep20-static-variable/</link>
      <pubDate>Tue, 13 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/c&#43;&#43;-ep20-static-variable/</guid>
      <description> C++ static 变量  初始化顺序     全局变量、文件域的 static 变量和类的 static 成员变量在 main 函数执行之前初始化    局部静态变量在第一次被使用时初始化   线程安全   从 C++ 11 起局部静态变量的初始化是线程安全的。 效率   由于要保证局部静态变量的线程安全，所以在每次访问时都需要 guard 判断变量是补始化，这样存在一个效率的问题。 struct C{ static const std::string &amp;amp;magic_static() { static std::string s = &amp;#34;hardy&amp;#34;; return s; } const std::string &amp;amp;s = magic_static(); const std::string &amp;amp;magic_static_ref() { return s; } };    在上面的例子中，调用 magic_static 的效率要比 magic_static_ref 低。 </description>
    </item>
    
  </channel>
</rss>